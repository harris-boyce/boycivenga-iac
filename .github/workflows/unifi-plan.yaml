name: UniFi Plan

# ============================================================================
# SECURITY & AUTHORITY BOUNDARIES
# ============================================================================
#
# This workflow enforces critical security and authority boundaries:
#
# 1. APPROVAL GATE:
#    - This workflow ONLY runs after PR approval (pull_request_review event)
#    - Cannot be triggered by branch push or automatic workflow completion
#    - PR must explicitly reference the render artifacts run ID to use
#    - Provides full traceability: PR number â†’ Approver â†’ Artifact source
#
# 2. EXECUTION BOUNDARY:
#    - This workflow is the ONLY permitted way to execute UniFi plan generation
#    - Terraform is used for schema validation only (stub mode, no controller access)
#    - Manual/local execution is PROHIBITED
#    - No alternative CI/CD systems are permitted
#
# 3. AUTHORITY BOUNDARY:
#    - NetBox is the authoritative source of infrastructure intent
#    - Terraform validates schemas; UniFi API applies configuration
#    - All infrastructure definitions MUST come from NetBox via render pipeline
#
# 4. SECURITY BOUNDARY:
#    - All artifacts MUST have valid SLSA provenance attestations
#    - Attestation verification is MANDATORY (enforced by verify-attestation action)
#    - Unattested or modified artifacts are automatically rejected
#
# See: docs/phase4/security.md for complete boundary documentation
# ============================================================================

on:
  # Trigger ONLY on PR approval - enforces approval gate
  pull_request_review:
    types: [submitted]
  # Allow manual triggering with specific artifact run (for testing)
  workflow_dispatch:
    inputs:
      render_run_id:
        description: 'Render artifacts workflow run ID to use'
        required: true
        type: string
      pr_number:
        description: 'PR number (for traceability)'
        required: false
        type: string
      site:
        description: 'Site to plan (leave empty for all sites)'
        required: false
        type: string
      allow_insecure_tls:
        description: 'Allow insecure TLS (self-signed certs) - TESTING ONLY'
        required: false
        type: boolean
        default: false

# Prevent concurrent plans
concurrency:
  group: unifi-plan-${{ github.event.inputs.site || 'all' }}
  cancel-in-progress: false

permissions:
  contents: read
  actions: read
  attestations: read   # Required for attestation verification

jobs:
  unifi-plan:
    # APPROVAL GATE: Only run on approved PRs or manual dispatch
    # - For PR reviews: Only process if review state is 'approved'
    # - For manual dispatch: Always allow (for testing/emergency)
    if: |
      (github.event_name == 'workflow_dispatch') ||
      (github.event_name == 'pull_request_review' && github.event.review.state == 'approved')

    strategy:
      matrix:
        # Define sites - this could be dynamically generated in the future
        site: [pennington, count-fleet-court]
      fail-fast: false

    # Use self-hosted docker-runner with site-specific label for UniFi connectivity
    runs-on:
      - self-hosted
      - docker-runner
      - ${{ matrix.site }}

    environment:
      name: production-${{ matrix.site }}

    steps:
      - name: Check if site should be processed
        id: check-site
        run: |
          # Skip this matrix item if a specific site was requested and it doesn't match
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && \
             [ -n "${{ github.event.inputs.site }}" ] && \
             [ "${{ github.event.inputs.site }}" != "${{ matrix.site }}" ]; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "â­ï¸  Skipping site ${{ matrix.site }} (requested: ${{ github.event.inputs.site }})"
          else
            echo "skip=false" >> $GITHUB_OUTPUT
            echo "âœ… Processing site: ${{ matrix.site }}"
          fi

      - name: Checkout repository
        if: steps.check-site.outputs.skip != 'true'
        uses: actions/checkout@v4

      - name: Extract PR metadata (for approval events)
        id: pr-metadata
        if: steps.check-site.outputs.skip != 'true' && github.event_name == 'pull_request_review'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          PR_NUMBER="${{ github.event.pull_request.number }}"
          APPROVER="${{ github.event.review.user.login }}"

          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "approver=$APPROVER" >> $GITHUB_OUTPUT

          echo "âœ… PR #$PR_NUMBER approved by @$APPROVER"

          # Fetch PR body to extract render run ID
          PR_BODY=$(gh pr view "$PR_NUMBER" --json body --jq '.body')

          # Extract render run ID from PR body using multiple pattern matching strategies
          # Pattern 1: "Render Run: 123" or "render_run_id: 123" (case insensitive)
          #   - Matches variations: render run, render_run, renderrun
          #   - Followed by optional "id", colon or whitespace, then digits
          PATTERN_RENDER_RUN='(?i)render[_ ]run[_ ]?(?:id)?[:\s]*\K\d+'

          # Pattern 2: GitHub Actions URL with /runs/ path
          #   - Matches: .../actions/runs/123456789
          PATTERN_ACTIONS_URL='actions/runs/\K\d+'

          RENDER_RUN_ID=$(echo "$PR_BODY" | grep -oP "$PATTERN_RENDER_RUN" | head -1 || echo "")

          if [ -z "$RENDER_RUN_ID" ]; then
            # Try extracting from GitHub Actions run URL
            RENDER_RUN_ID=$(echo "$PR_BODY" | grep -oP "$PATTERN_ACTIONS_URL" | head -1 || echo "")
          fi

          if [ -z "$RENDER_RUN_ID" ]; then
            echo "âŒ ERROR: Could not find render run ID in PR description"
            echo ""
            echo "PR body must contain render run ID in one of these formats:"
            echo "  - 'Render Run: 123456789'"
            echo "  - 'render_run_id: 123456789'"
            echo "  - Link to workflow run: 'https://github.com/.../actions/runs/123456789'"
            echo ""
            echo "Please update the PR description with the render artifacts workflow run ID."
            exit 1
          fi

          echo "render_run_id=$RENDER_RUN_ID" >> $GITHUB_OUTPUT
          echo "âœ… Found render run ID: $RENDER_RUN_ID"

      - name: Determine render run ID
        if: steps.check-site.outputs.skip != 'true'
        id: determine-run
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            RUN_ID="${{ github.event.inputs.render_run_id }}"
            PR_NUM="${{ github.event.inputs.pr_number }}"
            echo "Using manually specified run ID: $RUN_ID"
            [ -n "$PR_NUM" ] && echo "Associated with PR #$PR_NUM"
          else
            # Use the render run ID extracted from PR
            RUN_ID="${{ steps.pr-metadata.outputs.render_run_id }}"
            PR_NUM="${{ steps.pr-metadata.outputs.pr_number }}"
            APPROVER="${{ steps.pr-metadata.outputs.approver }}"
            echo "Using render run ID from approved PR #$PR_NUM: $RUN_ID"
            echo "Approved by: @$APPROVER"
          fi

          echo "run_id=$RUN_ID" >> $GITHUB_OUTPUT
          echo "pr_number=$PR_NUM" >> $GITHUB_OUTPUT
          echo "âœ… Will use artifacts from run: $RUN_ID"

      - name: Download attested artifacts
        if: steps.check-site.outputs.skip != 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          RUN_ID="${{ steps.determine-run.outputs.run_id }}"

          echo "ðŸ“¦ Downloading terraform-tfvars artifacts from run $RUN_ID..."

          # Create directory for artifacts
          mkdir -p artifacts/tfvars

          # Download terraform-tfvars artifact bundle
          if ! gh run download "$RUN_ID" --name terraform-tfvars --dir artifacts/tfvars; then
            echo "âŒ Failed to download terraform-tfvars artifact"
            echo "   This may indicate:"
            echo "   - The render artifacts workflow did not complete successfully"
            echo "   - The artifacts expired (retention period)"
            echo "   - The workflow run ID is invalid"
            exit 1
          fi

          echo "âœ… Artifacts downloaded successfully"
          echo ""
          echo "Downloaded tfvars files:"
          ls -lh artifacts/tfvars/

      - name: Verify artifact attestations (REQUIRED)
        if: steps.check-site.outputs.skip != 'true'
        id: verify-attestation
        # SECURITY BOUNDARY ENFORCEMENT:
        # This step is MANDATORY and enforces the trust boundary contract.
        # - All artifacts MUST have valid SLSA provenance attestations
        # - Verification failures BLOCK the workflow (fail-closed security)
        # - This step CANNOT be bypassed in production environment
        # - See: docs/phase4/attestation-gate.md for complete documentation
        uses: ./.github/actions/verify-attestation
        with:
          artifact-path: 'artifacts/tfvars/site-${{ matrix.site }}.tfvars.json'
          environment: 'prod'
          repo-owner: ${{ github.repository_owner }}
          repo-name: ${{ github.event.repository.name }}

      - name: Set up Terraform
        if: steps.check-site.outputs.skip != 'true'
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "~> 1.14"  # Align with local development (v1.14.3)

      - name: Configure Terraform provider (stub mode)
        if: steps.check-site.outputs.skip != 'true'
        run: |
          # Use stub/empty credentials for plan-only validation
          # This allows schema validation without actual UniFi controller access
          echo "ðŸ”§ Configuring Terraform provider in stub mode..."
          echo ""
          echo "Note: Provider credentials are stubbed for schema validation."
          echo "Actual provider operations would require real credentials."

          # Make credentials available to subsequent steps
          echo "TF_VAR_unifi_username=stub" >> $GITHUB_ENV
          echo "TF_VAR_unifi_password=stub" >> $GITHUB_ENV
          echo "TF_VAR_unifi_api_url=https://stub.local:8443" >> $GITHUB_ENV
          echo "TF_VAR_unifi_allow_insecure=true" >> $GITHUB_ENV

          echo "âœ… Provider configuration set"

      - name: Terraform Init
        if: steps.check-site.outputs.skip != 'true'
        working-directory: terraform
        run: |
          echo "ðŸš€ Initializing Terraform..."

          if ! terraform init -input=false; then
            echo "âŒ Terraform init failed"
            echo "   This may indicate:"
            echo "   - Invalid provider configuration in terraform.tf"
            echo "   - Network issues downloading provider plugins"
            echo "   - Backend configuration errors"
            exit 1
          fi

          echo "âœ… Terraform initialized successfully"
          echo ""
          echo "Installed providers:"
          terraform version
          terraform providers

      - name: Set up Python
        if: steps.check-site.outputs.skip != 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Python dependencies
        if: steps.check-site.outputs.skip != 'true'
        run: |
          echo "ðŸ“¦ Installing Python dependencies for UniFi plan..."
          pip install requests urllib3
          echo "âœ… Dependencies installed"

      - name: Configure UniFi credentials
        id: configure-unifi
        if: steps.check-site.outputs.skip != 'true'
        run: |
          echo "ðŸ”§ Configuring UniFi API credentials..."

          # Validate credentials are set first
          if [ -z "${{ secrets.UNIFI_USERNAME }}" ] || [ -z "${{ secrets.UNIFI_PASSWORD }}" ]; then
            echo "âš ï¸  WARNING: UniFi credentials not configured in GitHub Secrets"
            echo "   Python plan will be skipped"
            echo "   Add UNIFI_URL, UNIFI_USERNAME, UNIFI_PASSWORD secrets to enable"
            echo "skip_python_plan=true" >> $GITHUB_OUTPUT
          else
            # Only set UNIFI_* variables if secrets exist
            # This prevents empty strings from being set, which would
            # cause the UniFi client to fall back to TF_VAR_* stub values
            # echo "UNIFI_CONTROLLER_URL=${{ secrets.UNIFI_URL }}" >> $GITHUB_ENV
            echo "UNIFI_USERNAME=${{ secrets.UNIFI_USERNAME }}" >> $GITHUB_ENV
            echo "UNIFI_PASSWORD=${{ secrets.UNIFI_PASSWORD }}" >> $GITHUB_ENV

            # Handle TLS verification based on workflow input
            if [ "${{ github.event.inputs.allow_insecure_tls }}" = "true" ]; then
              echo "âš ï¸  WARNING: Insecure TLS enabled (self-signed certs allowed)"
              echo "   This should ONLY be used for testing with local controllers"
              echo "UNIFI_ALLOW_INSECURE=true" >> $GITHUB_ENV
            else
              echo "UNIFI_ALLOW_INSECURE=false" >> $GITHUB_ENV
            fi

            echo "âœ… UniFi credentials configured"
            echo "skip_python_plan=false" >> $GITHUB_OUTPUT
          fi

      - name: Terraform Validate
        if: steps.check-site.outputs.skip != 'true'
        working-directory: terraform
        run: |
          echo "âœ… Validating Terraform configuration..."

          if ! terraform validate; then
            echo "âŒ Terraform validation failed"
            echo "   This indicates a configuration or schema error."
            exit 1
          fi

          echo "âœ… Configuration is valid"

      - name: Terraform Plan (Binary)
        if: steps.check-site.outputs.skip != 'true'
        id: plan
        working-directory: terraform
        continue-on-error: true
        run: |
          TFVARS_FILE="../artifacts/tfvars/site-${{ matrix.site }}.tfvars.json"
          PLAN_FILE="tfplan-${{ matrix.site }}.binary"

          echo "ðŸ“‹ Running Terraform plan for site: ${{ matrix.site }}"
          echo "   Using tfvars: $TFVARS_FILE"
          echo "   Output plan: $PLAN_FILE"
          echo ""

          # Run plan and save binary output
          # Note: This may fail if provider requires actual connectivity
          # That's expected in stub mode - we still want to test schema validation
          if terraform plan \
              -var-file="$TFVARS_FILE" \
              -out="$PLAN_FILE" \
              -input=false \
              -detailed-exitcode; then
            PLAN_STATUS="success"
            PLAN_EXIT_CODE=$?
          else
            PLAN_EXIT_CODE=$?
            if [ $PLAN_EXIT_CODE -eq 2 ]; then
              PLAN_STATUS="changes"
              echo "âœ… Plan succeeded with changes (exit code 2)"
            else
              PLAN_STATUS="failed"
              echo "âš ï¸  Plan failed with exit code $PLAN_EXIT_CODE"
              echo "   This is expected in stub mode without actual provider access."
              echo "   Schema validation has already passed in the validate step."
            fi
          fi

          echo "plan_status=$PLAN_STATUS" >> $GITHUB_OUTPUT
          echo "plan_exit_code=$PLAN_EXIT_CODE" >> $GITHUB_OUTPUT

          # Consider it a success if we got this far with schema validation
          exit 0
        env:
          TF_VAR_unifi_username: ${{ secrets.UNIFI_USERNAME }}
          TF_VAR_unifi_password: ${{ secrets.UNIFI_PASSWORD }}
          TF_VAR_unifi_api_url: ${{ secrets.UNIFI_URL }}
          TF_VAR_unifi_allow_insecure: ${{ secrets.UNIFI_ALLOW_INSECURE || 'false' }}

      - name: Terraform Show (JSON)
        if: steps.check-site.outputs.skip != 'true' && steps.plan.outputs.plan_status != 'failed'
        working-directory: terraform
        run: |
          PLAN_FILE="tfplan-${{ matrix.site }}.binary"
          JSON_FILE="tfplan-${{ matrix.site }}.json"

          echo "ðŸ“„ Generating JSON representation of plan..."

          if [ -f "$PLAN_FILE" ]; then
            terraform show -json "$PLAN_FILE" > "$JSON_FILE"
            echo "âœ… JSON plan generated: $JSON_FILE"

            # Show summary
            echo ""
            echo "Plan summary:"
            jq -r '.resource_changes[]? | "\(.change.actions | join(",")): \(.type).\(.name)"' "$JSON_FILE" || echo "No resource changes"
          else
            echo "âš ï¸  Binary plan file not found, skipping JSON generation"
          fi

      - name: Generate Structured Plan Diff
        if: steps.check-site.outputs.skip != 'true' && steps.plan.outputs.plan_status != 'failed'
        working-directory: terraform
        run: |
          JSON_FILE="tfplan-${{ matrix.site }}.json"
          DIFF_FILE="tfplan-${{ matrix.site }}-diff.md"

          if [ ! -f "$JSON_FILE" ]; then
            echo "No JSON plan file found, skipping diff generation"
            exit 0
          fi

          echo "ðŸ“Š Generating structured diff summary..."

          # Use the Python script to generate the diff
          python3 ../scripts/generate-plan-diff.py "$JSON_FILE" "${{ matrix.site }}" > "$DIFF_FILE"

          if [ $? -eq 0 ]; then
            echo "âœ… Structured diff generated: $DIFF_FILE"
            echo ""
            echo "Diff preview:"
            head -30 "$DIFF_FILE"
          else
            echo "âš ï¸  Failed to generate structured diff"
          fi

      - name: Download state files (if available)
        id: download-state
        if: steps.check-site.outputs.skip != 'true'
        continue-on-error: true
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          SITE="${{ matrix.site }}"
          STATE_FILE="state/${SITE}-networks.json"

          echo "ðŸ“¥ Attempting to download previous state file..."

          # Create state directory
          mkdir -p state

          # Try to find most recent apply run with state artifact
          # Search last 10 workflow runs for apply workflow
          APPLY_RUNS=$(gh run list \
            --workflow=unifi-apply.yaml \
            --status=success \
            --limit=10 \
            --json databaseId \
            --jq '.[].databaseId')

          FOUND_STATE=false
          for RUN_ID in $APPLY_RUNS; do
            echo "  Checking run $RUN_ID for state artifact..."
            if gh run download "$RUN_ID" \
              --name "network-state-${SITE}" \
              --dir state 2>/dev/null; then
              echo "âœ… Found state file from run $RUN_ID"
              FOUND_STATE=true
              echo "state_downloaded=true" >> $GITHUB_OUTPUT
              break
            fi
          done

          if [ "$FOUND_STATE" = "false" ]; then
            echo "â„¹ï¸  No previous state file found"
            echo "   Python plan will run without recorded state (2-way diff)"
            echo "state_downloaded=false" >> $GITHUB_OUTPUT
          fi

      - name: Python Plan (UniFi API - Live State)
        id: python-plan
        if: |
          steps.check-site.outputs.skip != 'true' &&
          steps.configure-unifi.outputs.skip_python_plan != 'true'
        continue-on-error: true
        env:
          PYTHONUNBUFFERED: 1
        run: |
          SITE="${{ matrix.site }}"
          TFVARS_FILE="artifacts/tfvars/site-${SITE}.tfvars.json"
          STATE_FILE="state/${SITE}-networks.json"
          PLAN_OUTPUT="terraform/python-plan-${SITE}.txt"

          echo "ðŸ” Running Python plan for site: $SITE"
          echo "   Using tfvars: $TFVARS_FILE"
          echo "   State file: $STATE_FILE"
          echo ""

          # Create terraform directory if it doesn't exist
          mkdir -p terraform

          # Run Python plan with unbuffered output and capture to file
          # Use python3 -u flag for unbuffered output
          # stdbuf forces line buffering for real-time logging
          if stdbuf -oL -eL python3 -u scripts/plan_unifi.py \
              --tfvars "$TFVARS_FILE" \
              --site "$SITE" \
              --state-file "$STATE_FILE" \
              2>&1 | tee "$PLAN_OUTPUT"; then
            PLAN_EXIT_CODE=${PIPESTATUS[0]}
          else
            PLAN_EXIT_CODE=$?
          fi

          echo ""
          echo "plan_exit_code=$PLAN_EXIT_CODE" >> $GITHUB_OUTPUT

          # Interpret exit code
          if [ $PLAN_EXIT_CODE -eq 0 ]; then
            echo "âœ… Python plan: No changes detected"
            echo "plan_status=clean" >> $GITHUB_OUTPUT
            echo "plan_has_changes=false" >> $GITHUB_OUTPUT
          elif [ $PLAN_EXIT_CODE -eq 2 ]; then
            echo "â„¹ï¸  Python plan: Changes detected"
            echo "plan_status=changes" >> $GITHUB_OUTPUT
            echo "plan_has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸  Python plan failed with exit code $PLAN_EXIT_CODE"
            echo "   This may indicate:"
            echo "   - UniFi controller is unreachable"
            echo "   - Invalid credentials"
            echo "   - Network connectivity issues"
            echo "plan_status=failed" >> $GITHUB_OUTPUT
            echo "plan_has_changes=unknown" >> $GITHUB_OUTPUT
          fi

      - name: Generate Python Plan Summary (JSON)
        if: |
          steps.check-site.outputs.skip != 'true' &&
          steps.python-plan.outputs.plan_status != 'failed' &&
          steps.python-plan.outputs.plan_status != ''
        working-directory: terraform
        run: |
          SITE="${{ matrix.site }}"
          PLAN_OUTPUT="python-plan-${SITE}.txt"
          SUMMARY_FILE="python-plan-${SITE}-summary.json"

          echo "ðŸ“Š Generating Python plan summary..."

          # Parse plan output to extract counts
          # This is a simple parser - plan_unifi.py could be
          # enhanced to output JSON directly
          TO_CREATE=$(grep -oP "Networks to CREATE: \K\d+" \
            "$PLAN_OUTPUT" || echo "0")
          TO_UPDATE=$(grep -oP "Networks to UPDATE: \K\d+" \
            "$PLAN_OUTPUT" || echo "0")
          TO_DELETE=$(grep -oP "Networks to DELETE: \K\d+" \
            "$PLAN_OUTPUT" || echo "0")
          DRIFT_COUNT=$(grep -oP "DRIFT DETECTED: \K\d+" \
            "$PLAN_OUTPUT" || echo "0")

          # Check if clean
          if [ "${{ steps.python-plan.outputs.plan_has_changes }}" = "false" ]
          then
            IS_CLEAN=true
          else
            IS_CLEAN=false
          fi

          # Generate JSON summary
          cat > "$SUMMARY_FILE" << EOF
          {
            "site": "${SITE}",
            "is_clean": ${IS_CLEAN},
            "exit_code": ${{ steps.python-plan.outputs.plan_exit_code }},
            "changes": {
              "to_create": ${TO_CREATE},
              "to_update": ${TO_UPDATE},
              "to_delete": ${TO_DELETE}
            },
            "drift_detected": $([ "$DRIFT_COUNT" -gt 0 ] && echo "true" \
              || echo "false"),
            "drift_count": ${DRIFT_COUNT},
            "state_available": ${{ steps.download-state.outputs.state_downloaded || 'false' }}
          }
          EOF

          echo "âœ… Summary generated: $SUMMARY_FILE"
          cat "$SUMMARY_FILE"

      - name: Evaluate Policy with OPA
        id: policy
        if: steps.check-site.outputs.skip != 'true' && steps.plan.outputs.plan_status != 'failed'
        working-directory: terraform
        run: |
          PLAN_JSON="tfplan-${{ matrix.site }}.json"

          if [ ! -f "$PLAN_JSON" ]; then
            echo "âš ï¸  Plan JSON file not found, skipping policy evaluation"
            exit 0
          fi

          echo "ðŸ” Installing Open Policy Agent..."

          # Download and install OPA (pinned version for reproducibility)
          OPA_VERSION="0.60.0"
          OPA_CHECKSUM="7d7cb45d9e6390646e603456503ca1232180604accc646de823e4d2c363dbeb0"

          curl -L -o opa "https://github.com/open-policy-agent/opa/releases/download/v${OPA_VERSION}/opa_linux_amd64_static"

          # Verify checksum for security
          echo "${OPA_CHECKSUM}  opa" | sha256sum -c - || {
            echo "âŒ OPA checksum verification failed"
            exit 1
          }

          chmod +x opa

          echo "âœ… OPA installed: $(./opa version)"

          # Prepare policy input document
          echo "ðŸ“‹ Preparing policy input..."

          # Determine attestation verification status
          # If verification step succeeded and verified count > 0, then verified = true
          ATTESTATION_VERIFIED="false"
          if [ "${{ steps.verify-attestation.outputs.verified-count }}" -gt "0" ]; then
            ATTESTATION_VERIFIED="true"
          fi

          # Create metadata JSON (no longer need deletion_approved)
          cat > policy-input-metadata.json << EOF
          {
            "artifact": {
              "path": "site-${{ matrix.site }}.tfvars.json",
              "site": "${{ matrix.site }}"
            },
            "provenance": {
              "render_run_id": "${{ steps.determine-run.outputs.run_id }}",
              "attestation_verified": ${ATTESTATION_VERIFIED},
              "pr_number": "${{ steps.determine-run.outputs.pr_number || 'unknown' }}",
              "approver": "${{ steps.pr-metadata.outputs.approver || 'manual' }}",
              "approved_at": "${{ github.event.review.submitted_at || github.event.head_commit.timestamp }}"
            }
          }
          EOF

          # Create combined input document
          echo "ðŸ“„ Creating policy input document..."
          jq -n \
            --argjson plan "$(cat "$PLAN_JSON")" \
            --argjson metadata "$(cat policy-input-metadata.json)" \
            '{plan: $plan, metadata: $metadata}' > policy-input.json

          # Evaluate policy
          echo "ðŸ” Evaluating policy..."
          echo ""

          # Extract structured decision output (agent-consumable)
          echo "ðŸ“Š Extracting structured decision output..."
          ./opa eval \
            --bundle ../.github/policies/ \
            --input policy-input.json \
            --format json \
            'data.terraform.plan.decision' > tfplan-${{ matrix.site }}-decision.json

          # Extract human-readable explanation
          echo "ðŸ“ Extracting human explanation..."
          ./opa eval \
            --bundle ../.github/policies/ \
            --input policy-input.json \
            --format raw \
            'data.terraform.plan.explanation' > tfplan-${{ matrix.site }}-explanation.txt

          # Extract outcome for workflow control
          OUTCOME=$(jq -r '.result[0].expressions[0].value.outcome' tfplan-${{ matrix.site }}-decision.json)
          echo "outcome=${OUTCOME}" >> $GITHUB_OUTPUT

          # Display the explanation to console
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "POLICY DECISION"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          cat tfplan-${{ matrix.site }}-explanation.txt
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""

          # Check if policy allows the plan
          if ./opa eval \
              --bundle ../.github/policies/ \
              --input policy-input.json \
              --format pretty \
              'data.terraform.plan.allow' | grep -q "true"; then
            echo "âœ… Policy evaluation PASSED"
            echo "policy_result=pass" >> $GITHUB_OUTPUT

            # Check if human approval is required
            APPROVAL_REQUIRED=$(./opa eval \
              --bundle ../.github/policies/ \
              --input policy-input.json \
              --format raw \
              'data.terraform.plan.approval_required')

            echo "approval_required=$APPROVAL_REQUIRED" >> $GITHUB_OUTPUT

            if [ "$APPROVAL_REQUIRED" = "true" ]; then
              echo "âš ï¸  Plan requires additional approval before apply"
            else
              echo "âœ… Plan can proceed to apply without additional approval"
            fi
          else
            echo "âŒ Policy evaluation FAILED"
            echo "policy_result=fail" >> $GITHUB_OUTPUT
            echo "approval_required=false" >> $GITHUB_OUTPUT

            # Explanation already displayed above
            echo "âŒ Plan cannot proceed - see policy decision above for details"

            exit 1
          fi

      - name: Record Approval Requirement
        if: steps.check-site.outputs.skip != 'true' && steps.policy.outputs.policy_result == 'pass'
        working-directory: terraform
        run: |
          APPROVAL_REQUIRED="${{ steps.policy.outputs.approval_required }}"
          SITE="${{ matrix.site }}"

          # Create approval metadata file
          cat > "tfplan-${SITE}-approval.json" << EOF
          {
            "site": "${SITE}",
            "approval_required": ${APPROVAL_REQUIRED},
            "pr_number": "${{ steps.determine-run.outputs.pr_number }}",
            "plan_run_id": "${{ github.run_id }}",
            "evaluated_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          }
          EOF

          echo "âœ… Approval metadata recorded"
          cat "tfplan-${SITE}-approval.json"

      - name: Upload UniFi Plans
        uses: actions/upload-artifact@v4
        if: steps.check-site.outputs.skip != 'true' && always()
        with:
          name: unifi-plan-${{ matrix.site }}
          path: |
            terraform/tfplan-${{ matrix.site }}.binary
            terraform/tfplan-${{ matrix.site }}.json
            terraform/tfplan-${{ matrix.site }}-diff.md
            terraform/tfplan-${{ matrix.site }}-approval.json
            terraform/tfplan-${{ matrix.site }}-decision.json
            terraform/tfplan-${{ matrix.site }}-explanation.txt
            terraform/python-plan-${{ matrix.site }}.txt
            terraform/python-plan-${{ matrix.site }}-summary.json
          retention-days: 30

      # BACKWARD COMPATIBILITY: Upload with legacy name during transition (30 days)
      - name: Upload Plans (Legacy Name)
        uses: actions/upload-artifact@v4
        if: steps.check-site.outputs.skip != 'true' && always()
        with:
          name: terraform-plan-${{ matrix.site }}
          path: |
            terraform/tfplan-${{ matrix.site }}.binary
            terraform/tfplan-${{ matrix.site }}.json
            terraform/tfplan-${{ matrix.site }}-diff.md
            terraform/tfplan-${{ matrix.site }}-approval.json
            terraform/tfplan-${{ matrix.site }}-decision.json
            terraform/tfplan-${{ matrix.site }}-explanation.txt
            terraform/python-plan-${{ matrix.site }}.txt
            terraform/python-plan-${{ matrix.site }}-summary.json
          retention-days: 30

      - name: Plan Summary
        if: steps.check-site.outputs.skip != 'true' && always()
        run: |
          DIFF_FILE="terraform/tfplan-${{ matrix.site }}-diff.md"
          PR_NUM="${{ steps.determine-run.outputs.pr_number }}"

          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          ## UniFi Plan: ${{ matrix.site }}

          **Status**: ${{ steps.plan.outputs.plan_status || 'unknown' }}
          **Exit Code**: ${{ steps.plan.outputs.plan_exit_code || 'N/A' }}

          ### Approval & Traceability
          EOF

          # Add PR and approval info if available
          if [ -n "$PR_NUM" ]; then
            if [ "${{ github.event_name }}" = "pull_request_review" ]; then
              cat >> $GITHUB_STEP_SUMMARY << PREOF
          - **PR**: [#$PR_NUM](${{ github.server_url }}/${{ github.repository }}/pull/$PR_NUM)
          - **Approved By**: @${{ steps.pr-metadata.outputs.approver }}
          - **Approval Event**: ${{ github.event.review.submitted_at }}
          PREOF
            else
              cat >> $GITHUB_STEP_SUMMARY << PREOF
          - **PR**: [#$PR_NUM](${{ github.server_url }}/${{ github.repository }}/pull/$PR_NUM) (manual dispatch)
          PREOF
            fi
          else
            echo "- **Trigger**: Manual dispatch (no PR associated)" >> $GITHUB_STEP_SUMMARY
          fi

          cat >> $GITHUB_STEP_SUMMARY << 'EOF'

          ### Artifacts Used
          - **Render Run**: [${{ steps.determine-run.outputs.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ steps.determine-run.outputs.run_id }})
          - **tfvars File**: `site-${{ matrix.site }}.tfvars.json`
          - **Attestation**: âœ… Verified

          ### Policy Evaluation
          - **Policy Engine**: Open Policy Agent (OPA)
          - **Decision**: ${{ steps.policy.outputs.outcome == 'auto_approve' && 'âœ… AUTO-APPROVE' || steps.policy.outputs.outcome == 'require_approval' && 'âš ï¸ REQUIRE APPROVAL' || steps.policy.outputs.outcome == 'deny' && 'âŒ DENY' || 'N/A' }}
          - **Policy Result**: ${{ steps.policy.outputs.policy_result == 'pass' && 'âœ… PASSED' || steps.policy.outputs.policy_result == 'fail' && 'âŒ FAILED' || 'âš ï¸ SKIPPED' }}

          EOF

          # Add decision explanation if available
          if [ -f "terraform/tfplan-${{ matrix.site }}-explanation.txt" ]; then
            cat >> $GITHUB_STEP_SUMMARY << 'EXPLANATIONEOF'

          ### ðŸ“‹ Policy Decision Explanation

          ```
          EXPLANATIONEOF
            cat "terraform/tfplan-${{ matrix.site }}-explanation.txt" >> $GITHUB_STEP_SUMMARY
            cat >> $GITHUB_STEP_SUMMARY << 'EXPLANATIONEOF'
          ```

          EXPLANATIONEOF
          fi

          cat >> $GITHUB_STEP_SUMMARY << 'EOF'

          - Binary plan: `tfplan-${{ matrix.site }}.binary`
          - JSON plan: `tfplan-${{ matrix.site }}.json`
          - Structured diff: `tfplan-${{ matrix.site }}-diff.md`
          - **Decision output**: `tfplan-${{ matrix.site }}-decision.json` (agent-consumable)
          - **Explanation**: `tfplan-${{ matrix.site }}-explanation.txt` (human-readable)

          EOF

          # Append structured diff if available
          if [ -f "$DIFF_FILE" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "---" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            cat "$DIFF_FILE" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Add Python Plan section
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'

          ---

          ## Python Plan (UniFi API - Live State)

          EOF

          # Check if Python plan ran
          PYTHON_PLAN_FILE="terraform/python-plan-${{ matrix.site }}.txt"
          PYTHON_SUMMARY_FILE="terraform/python-plan-${{ matrix.site }}-summary.json"

          if [ "${{ steps.configure-unifi.outputs.skip_python_plan }}" = "true" ]; then
            cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          âš ï¸ **Python plan was skipped** - UniFi credentials not configured

          To enable real drift detection:
          1. Add GitHub Secrets: UNIFI_URL, UNIFI_USERNAME, UNIFI_PASSWORD
          2. Re-run workflow

          EOF
          elif [ "${{ steps.python-plan.outputs.plan_status }}" = "failed" ]; then
            cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          âŒ **Python plan failed** - See logs for details

          Possible causes:
          - UniFi controller unreachable
          - Invalid credentials
          - Network connectivity issues

          EOF
          elif [ "${{ steps.python-plan.outputs.plan_status }}" = "" ]; then
            cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          â„¹ï¸ **Python plan did not run** - Terraform validation may have failed

          EOF
          else
            # Show Python plan results
            if [ -f "$PYTHON_SUMMARY_FILE" ]; then
              TO_CREATE=$(jq -r '.changes.to_create' "$PYTHON_SUMMARY_FILE")
              TO_UPDATE=$(jq -r '.changes.to_update' "$PYTHON_SUMMARY_FILE")
              TO_DELETE=$(jq -r '.changes.to_delete' "$PYTHON_SUMMARY_FILE")
              DRIFT_COUNT=$(jq -r '.drift_count' "$PYTHON_SUMMARY_FILE")
              IS_CLEAN=$(jq -r '.is_clean' "$PYTHON_SUMMARY_FILE")

              if [ "$IS_CLEAN" = "true" ]; then
                cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          âœ… **No changes detected** - Infrastructure matches desired state

          EOF
              else
                cat >> $GITHUB_STEP_SUMMARY << PYEOF
          ðŸ“ **Changes detected:**

          - **Create**: ${TO_CREATE} network(s)
          - **Update**: ${TO_UPDATE} network(s)
          - **Delete**: ${TO_DELETE} network(s)

          PYEOF

                if [ "$DRIFT_COUNT" -gt 0 ]; then
                  cat >> $GITHUB_STEP_SUMMARY << DRIFTEOF
          âš ï¸ **Drift detected**: ${DRIFT_COUNT} network(s) modified outside this tool

          DRIFTEOF
                fi
              fi
            fi

            # Show full plan output
            if [ -f "$PYTHON_PLAN_FILE" ]; then
              cat >> $GITHUB_STEP_SUMMARY << 'EOF'

          ### Detailed Plan Output

          ```
          EOF
              cat "$PYTHON_PLAN_FILE" >> $GITHUB_STEP_SUMMARY
              cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          ```

          EOF
            fi

            cat >> $GITHUB_STEP_SUMMARY << 'EOF'

          ### Artifacts
          - **Plan output**: `python-plan-${{ matrix.site }}.txt`
          - **Summary**: `python-plan-${{ matrix.site }}-summary.json`

          EOF
          fi

          cat >> $GITHUB_STEP_SUMMARY << 'EOF'

          ---

          ### Schema Validation (Terraform)
          - âœ… Provider schema validated
          - âœ… Configuration syntax valid
          - âœ… Variable definitions match

          ### Architecture Notes
          This workflow uses a **hybrid approach**:
          - **Terraform Plan**: Schema validation only (stub credentials)
          - **Python Plan**: Real drift detection (live UniFi API)

          The Terraform plan validates configuration schemas without controller access.
          The Python plan shows actual state from the UniFi controller.

          See [terraform/README.md](terraform/README.md) for configuration details.
          EOF

  plan-summary:
    runs-on: ubuntu-latest
    needs: unifi-plan
    if: always()
    steps:
      - name: Overall Summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          # UniFi Plan Workflow Complete

          ## Approval-Gated Execution

          This workflow enforces PR approval before UniFi plan execution:
          - âœ… **Trigger**: Pull request approval event only
          - âœ… **Artifact Reference**: Explicit render run ID from PR description
          - âœ… **Traceability**: PR number, approver, and timestamps recorded
          - âŒ **Not Triggered By**: Direct push to branch, workflow_run, or unapproved PRs

          ## What This Workflow Does

          This workflow demonstrates the complete UniFi plan pipeline:

          1. âœ… **Extract PR Metadata** - Captures PR number, approver, and render run ID
          2. âœ… **Download Attested Artifacts** - Retrieves tfvars from specified render run
          3. âœ… **Verify Attestations** - Ensures artifacts have valid SLSA provenance
          4. âœ… **Schema Validation** - Validates against UniFi provider schema (Terraform stub mode)
          5. âœ… **Generate Plan** - Creates both binary and JSON plan outputs
          6. âœ… **Policy Evaluation** - OPA evaluates plan against organizational policies
          7. âœ… **Record Traceability** - Links plan to PR approval and artifact source

          ## Trust Boundary Compliance

          This workflow enforces the trust boundary contract:
          - âœ… Only attested artifacts are consumed
          - âœ… Attestation verification is required (not optional)
          - âœ… Verification failures block the workflow
          - âœ… Uses reusable attestation gate action (`.github/actions/verify-attestation`)

          See [docs/phase4/attestation-gate.md](docs/phase4/attestation-gate.md) for gate documentation.

          ## Policy Gate

          This workflow includes automated policy evaluation:
          - âœ… **Policy Engine**: Open Policy Agent (OPA)
          - âœ… **Deterministic**: Same inputs always produce same outputs
          - âœ… **CI-Only**: Evaluation only runs in GitHub Actions
          - âœ… **No Bypass**: Policy failures block the workflow

          See [docs/phase5/policy-engine.md](docs/phase5/policy-engine.md) for policy documentation.

          ## Provider Configuration

          - **Provider**: UniFi (paultyng/unifi)
          - **Mode**: Stub credentials for schema validation
          - **Decoupling**: Provider config separated from artifact generation

          ## Hybrid Architecture

          This workflow uses a hybrid approach:
          - **Terraform**: Schema validation only (stub credentials, no controller access)
          - **UniFi API**: Actual infrastructure application (via Python scripts)
          - **Reason**: Terraform provider had CI/CD compatibility issues

          ## Next Steps

          To apply these plans:
          1. Review the plan JSON outputs
          2. Manually trigger the UniFi Apply workflow
          3. Configuration applied via UniFi API (not Terraform)

          See [docs/phase3/terraform-boundary.md](docs/phase3/terraform-boundary.md) for complete details.
          EOF
