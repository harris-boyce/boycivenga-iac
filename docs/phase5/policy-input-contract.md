# Policy Input Contract

## Overview

This document defines the structured input formats for policy engine evaluation in the infrastructure deployment pipeline. The policy engine (Open Policy Agent/OPA) evaluates Terraform plans before apply operations, and all inputs to the policy engine are strictly structured data with well-defined schemas.

**Policy Engine**: Open Policy Agent (OPA)

**Status**: Active and Enforced

**Last Updated**: Phase 5

**Contract Version**: 1.0.0

## Contract Principles

### 1. Structured Data Only

**Requirement**: All policy inputs MUST be structured data formats (JSON).

**Rationale**:
- Enables deterministic policy evaluation
- Allows precise querying and validation
- Prevents ambiguity in policy rules
- Facilitates automated testing and verification

**Explicitly Prohibited**:
- ❌ Raw log file parsing
- ❌ Text-based output parsing
- ❌ Regular expressions on unstructured text
- ❌ String matching on console output
- ❌ Parsing of formatted terminal output

### 2. No Raw Log/Text Parsing

**Requirement**: Policy engine MUST NOT parse raw logs, text output, or unstructured data.

**Enforcement**:
- Policy inputs are limited to JSON documents
- OPA Rego policies operate on structured JSON objects only
- No file I/O or external data access in policies
- All data provided explicitly as input documents

**Compliant Examples**:
- ✅ Terraform plan JSON (`terraform show -json`)
- ✅ Structured metadata JSON documents
- ✅ SLSA provenance attestation JSON
- ✅ Pre-parsed and structured change summaries

**Non-Compliant Examples**:
- ❌ Parsing `terraform plan` terminal output
- ❌ Parsing GitHub Actions logs
- ❌ Parsing workflow step output text
- ❌ Parsing `git log` or `git diff` output

### 3. Complete Input Specification

**Requirement**: All policy inputs MUST be fully specified in this document.

**Guarantees**:
- Input formats are versioned and stable
- Breaking changes require version bump
- All inputs are documented with examples
- Input generation is traceable to source

## Policy Input Sources

The policy engine receives three primary input sources, all in structured JSON format:

| Input Source | Format | Generated By | Purpose |
|--------------|--------|--------------|---------|
| **Terraform Plan JSON** | Terraform JSON plan format | `terraform show -json` | Resource change evaluation |
| **Artifact Metadata** | Custom JSON schema | Workflow logic | Provenance and approval tracking |
| **Scoped Changes** | Derived from plan JSON | Extracted in workflow | Site/VLAN/resource-specific analysis |

---

## Input 1: Terraform Plan JSON

### Overview

The Terraform plan JSON is the primary input for policy evaluation. It contains the complete plan representation including all resource changes, before/after states, and configuration details.

### Source

**Command**: `terraform show -json tfplan-{site}.binary`

**Location in Workflow**: `.github/workflows/terraform-plan.yaml`

**Generation Step**: "Terraform Show (JSON)"

### Format Specification

**Standard**: Terraform JSON plan format (version 1.2+)

**Documentation**: https://developer.hashicorp.com/terraform/internals/json-format

**Key Fields**:
- `format_version` (string): JSON format version (e.g., "1.2")
- `terraform_version` (string): Terraform version used (e.g., "1.9.0")
- `planned_values` (object): Full planned state after apply
- `resource_changes` (array): List of all resource changes
- `output_changes` (object): Changes to outputs
- `prior_state` (object): State before plan
- `configuration` (object): Root module configuration

### Resource Changes Schema

Each element in `resource_changes` array represents a single resource change:

```json
{
  "address": "unifi_network.management",
  "mode": "managed",
  "type": "unifi_network",
  "name": "management",
  "provider_name": "registry.terraform.io/paultyng/unifi",
  "change": {
    "actions": ["create"],
    "before": null,
    "after": {
      "name": "Management",
      "purpose": "corporate",
      "vlan_id": 100,
      "site": "default"
    },
    "after_unknown": {},
    "before_sensitive": false,
    "after_sensitive": false
  }
}
```

### Change Actions

The `change.actions` array indicates the type of change:

| Actions | Meaning | Destructive? |
|---------|---------|--------------|
| `["create"]` | New resource will be created | No |
| `["update"]` | Existing resource will be updated in-place | No |
| `["delete"]` | Resource will be destroyed | **Yes** |
| `["delete", "create"]` | Resource will be replaced (destroy then create) | **Yes** |
| `["create", "delete"]` | Resource will be replaced (create then destroy) | **Yes** |
| `["no-op"]` | No changes (informational only) | No |

### Example: Complete Terraform Plan JSON

```json
{
  "format_version": "1.2",
  "terraform_version": "1.9.0",
  "planned_values": {
    "root_module": {
      "resources": [
        {
          "address": "unifi_network.management",
          "mode": "managed",
          "type": "unifi_network",
          "name": "management",
          "values": {
            "name": "Management",
            "vlan_id": 100
          }
        }
      ]
    }
  },
  "resource_changes": [
    {
      "address": "unifi_network.management",
      "mode": "managed",
      "type": "unifi_network",
      "name": "management",
      "change": {
        "actions": ["create"],
        "before": null,
        "after": {
          "name": "Management",
          "purpose": "corporate",
          "vlan_id": 100
        }
      }
    }
  ],
  "output_changes": {},
  "prior_state": {
    "values": {
      "root_module": {
        "resources": []
      }
    }
  }
}
```

### Policy Usage

The Terraform plan JSON is provided to OPA as part of the combined input document under the `plan` key:

```rego
package terraform.plan

# Access resource changes
resource_changes := input.plan.resource_changes

# Check for destructive changes
has_deletions if {
    some change in resource_changes
    "delete" in change.change.actions
}

# Count creates
create_count := count([r | some r in resource_changes; r.change.actions == ["create"]])
```

**Policy Package**: `terraform.plan`

**Access Path**: `input.plan.*`

### Validation Rules

1. ✅ MUST be valid JSON (parseable by standard JSON parsers)
2. ✅ MUST conform to Terraform JSON plan format specification
3. ✅ MUST be generated by `terraform show -json` (not manually constructed)
4. ✅ MUST contain `format_version` field
5. ✅ MUST contain `resource_changes` array (may be empty)

---

## Input 2: Artifact Metadata

### Overview

Artifact metadata provides context about the source artifacts (tfvars files), their provenance, and the approval chain. This metadata enables the policy engine to verify that artifacts are properly attested and approved.

### Source

**Generation**: Constructed in workflow from multiple sources

**Location in Workflow**: `.github/workflows/terraform-plan.yaml`

**Generation Step**: "Evaluate Policy with OPA" (metadata construction)

### Format Specification

**Schema**: Custom JSON schema defined for this pipeline

**Version**: 1.0.0

### Schema Definition

```json
{
  "artifact": {
    "path": "site-{site}.tfvars.json",
    "site": "{site-name}"
  },
  "provenance": {
    "render_run_id": "{workflow-run-id}",
    "attestation_verified": true|false,
    "pr_number": "{pr-number}",
    "approver": "{github-username}",
    "approved_at": "{iso8601-timestamp}"
  },
  "deletion_approved": true|false
}
```

### Field Specifications

#### artifact.path
- **Type**: string
- **Required**: Yes
- **Format**: Filename of the tfvars artifact
- **Example**: `"site-pennington.tfvars.json"`
- **Source**: Workflow matrix site variable
- **Constraint**: MUST match pattern `site-{site}.tfvars.json`

#### artifact.site
- **Type**: string
- **Required**: Yes
- **Format**: Site identifier (slug)
- **Example**: `"pennington"`
- **Source**: Workflow matrix site variable
- **Constraint**: MUST be lowercase alphanumeric with hyphens

#### provenance.render_run_id
- **Type**: string
- **Required**: Yes
- **Format**: GitHub Actions workflow run ID
- **Example**: `"1234567890"`
- **Source**: Extracted from PR description or workflow input
- **Constraint**: MUST be numeric string
- **Purpose**: Links artifact to specific render workflow execution

#### provenance.attestation_verified
- **Type**: boolean
- **Required**: Yes
- **Values**: `true` or `false`
- **Source**: Result of attestation verification step
- **Constraint**: MUST be `true` for policy to pass
- **Purpose**: Confirms artifact has valid SLSA provenance

#### provenance.pr_number
- **Type**: string
- **Required**: Yes
- **Format**: Pull request number
- **Example**: `"42"`
- **Source**: GitHub event context or workflow input
- **Constraint**: MUST be numeric string or `"unknown"`
- **Purpose**: Traceability to approval source

#### provenance.approver
- **Type**: string
- **Required**: Yes
- **Format**: GitHub username
- **Example**: `"maintainer-username"`
- **Source**: PR review event or `"manual"` for workflow dispatch
- **Constraint**: MUST be non-empty string
- **Purpose**: Tracks who approved the plan

#### provenance.approved_at
- **Type**: string
- **Required**: Yes
- **Format**: ISO 8601 timestamp
- **Example**: `"2024-01-15T10:30:00Z"`
- **Source**: GitHub event timestamp
- **Constraint**: MUST be valid ISO 8601 format
- **Purpose**: Records when approval occurred

#### deletion_approved
- **Type**: boolean
- **Required**: Yes
- **Values**: `true` or `false`
- **Default**: `false`
- **Source**: Explicit workflow input or metadata flag
- **Purpose**: Explicit approval flag for destructive changes

### Example: Complete Artifact Metadata

```json
{
  "artifact": {
    "path": "site-pennington.tfvars.json",
    "site": "pennington"
  },
  "provenance": {
    "render_run_id": "7890123456",
    "attestation_verified": true,
    "pr_number": "42",
    "approver": "harris-boyce",
    "approved_at": "2024-01-15T10:30:00Z"
  },
  "deletion_approved": false
}
```

### Policy Usage

The artifact metadata is provided to OPA as part of the combined input document under the `metadata` key:

```rego
package terraform.plan

# Check attestation
artifact_attested if {
    input.metadata.provenance.attestation_verified == true
}

# Check deletion approval
deletion_approved if {
    input.metadata.deletion_approved == true
}

# Verify provenance completeness
has_valid_provenance if {
    input.metadata.provenance.render_run_id
    count(input.metadata.provenance.render_run_id) > 0
}
```

**Policy Package**: `terraform.plan`

**Access Path**: `input.metadata.*`

### Validation Rules

1. ✅ MUST be valid JSON
2. ✅ MUST contain all required fields
3. ✅ Field values MUST match specified types
4. ✅ `attestation_verified` MUST be `true` for production use
5. ✅ `deletion_approved` MUST be explicitly set (no defaults in policy)

---

## Input 3: Scoped Changes

### Overview

Scoped changes represent resource changes organized by scope (site, VLAN, resource type, etc.). This structure is derived from the Terraform plan JSON and provides convenience access for common policy patterns.

### Source

**Derivation**: Extracted from Terraform plan JSON within OPA policies

**Location**: Policy files (`.github/policies/terraform_plan.rego`)

**Method**: Rego rules that query `input.plan.resource_changes`

### Scope Dimensions

Policy rules can scope changes by multiple dimensions:

| Scope | Description | Example |
|-------|-------------|---------|
| **Site** | Changes affecting a specific site | All resources for site "pennington" |
| **Resource Type** | Changes to specific resource types | All `unifi_network` resources |
| **Action** | Changes by action type | All deletions, all creates |
| **VLAN** | Changes affecting specific VLANs | Resources with `vlan_id == 100` |
| **Attribute** | Changes to specific attributes | Resources modifying `name` field |

### Implementation in Policy

Scoped changes are implemented as Rego rules that filter `resource_changes`:

#### By Site (Implicit)

Site scope is implicit in the input - each policy evaluation is for a single site's plan:

```rego
# All resource changes are implicitly for the current site
all_site_resources := input.plan.resource_changes
```

#### By Resource Type

```rego
# Get all network resources
network_resources contains resource if {
    some resource in input.plan.resource_changes
    resource.type == "unifi_network"
}

# Get all VLAN resources
vlan_resources contains resource if {
    some resource in input.plan.resource_changes
    resource.type == "unifi_vlan"
}
```

#### By Action

```rego
# Resources to be created
resources_to_create contains resource if {
    some resource in input.plan.resource_changes
    "create" in resource.change.actions
    not "delete" in resource.change.actions
}

# Resources to be updated
resources_to_update contains resource if {
    some resource in input.plan.resource_changes
    "update" in resource.change.actions
}

# Resources to be deleted (destructive)
resources_to_delete contains resource if {
    some resource in input.plan.resource_changes
    "delete" in resource.change.actions
}
```

#### By VLAN

```rego
# Resources affecting VLAN 100
vlan_100_resources contains resource if {
    some resource in input.plan.resource_changes
    resource.change.after.vlan_id == 100
}

# All VLANs being modified
modified_vlans contains vlan_id if {
    some resource in input.plan.resource_changes
    vlan_id := resource.change.after.vlan_id
}
```

#### By Attribute Changes

```rego
# Resources with name changes
name_changes contains resource if {
    some resource in input.plan.resource_changes
    resource.change.before.name != resource.change.after.name
}

# Resources with VLAN ID changes
vlan_id_changes contains resource if {
    some resource in input.plan.resource_changes
    resource.change.before.vlan_id != resource.change.after.vlan_id
}
```

### Example: Scoped Change Analysis

```rego
package terraform.plan

import future.keywords.contains
import future.keywords.if

# Scope 1: By action (destructive changes)
has_destructive_changes if {
    count(resources_to_delete) > 0
}

resources_to_delete contains resource if {
    some resource in input.plan.resource_changes
    "delete" in resource.change.actions
}

# Scope 2: By resource type
network_creates contains resource if {
    some resource in input.plan.resource_changes
    resource.type == "unifi_network"
    "create" in resource.change.actions
}

# Scope 3: By attribute (management VLANs)
management_vlan_changes contains resource if {
    some resource in input.plan.resource_changes
    resource.change.after.purpose == "corporate"
    "update" in resource.change.actions
}

# Scope 4: Multi-dimensional (delete management VLANs)
management_vlan_deletions contains resource if {
    some resource in input.plan.resource_changes
    resource.type == "unifi_network"
    resource.change.before.purpose == "corporate"
    "delete" in resource.change.actions
}
```

### Policy Usage

Scoped changes are defined within policy files and accessed by policy rules:

```rego
# Policy rule using scoped changes
deny contains msg if {
    count(management_vlan_deletions) > 0
    not input.metadata.deletion_approved
    msg := sprintf("Deletion of %d management VLANs requires explicit approval",
                   [count(management_vlan_deletions)])
}
```

### Validation Rules

1. ✅ Scoped changes MUST be derived from `input.plan.resource_changes`
2. ✅ Scoped changes MUST NOT rely on external data or file I/O
3. ✅ All scoping logic MUST be deterministic (no randomness)
4. ✅ Scoped changes MUST be recomputed on each evaluation (no caching)

---

## Combined Input Document

### Overview

The policy engine receives a single combined JSON document that includes all input sources.

### Structure

```json
{
  "plan": { /* Terraform plan JSON */ },
  "metadata": { /* Artifact metadata */ }
}
```

### Generation

**Location**: `.github/workflows/terraform-plan.yaml`

**Command**:
```bash
jq -n \
  --argjson plan "$(cat tfplan-{site}.json)" \
  --argjson metadata "$(cat policy-input-metadata.json)" \
  '{plan: $plan, metadata: $metadata}' > policy-input.json
```

### Complete Example

```json
{
  "plan": {
    "format_version": "1.2",
    "terraform_version": "1.9.0",
    "resource_changes": [
      {
        "address": "unifi_network.management",
        "mode": "managed",
        "type": "unifi_network",
        "name": "management",
        "change": {
          "actions": ["create"],
          "before": null,
          "after": {
            "name": "Management",
            "purpose": "corporate",
            "vlan_id": 100
          }
        }
      }
    ]
  },
  "metadata": {
    "artifact": {
      "path": "site-pennington.tfvars.json",
      "site": "pennington"
    },
    "provenance": {
      "render_run_id": "7890123456",
      "attestation_verified": true,
      "pr_number": "42",
      "approver": "harris-boyce",
      "approved_at": "2024-01-15T10:30:00Z"
    },
    "deletion_approved": false
  }
}
```

### Policy Evaluation

**Command**:
```bash
opa eval \
  --bundle .github/policies/ \
  --input policy-input.json \
  --format pretty \
  'data.terraform.plan.allow'
```

**Decision Path**: `data.terraform.plan.allow`

**Result**: `true` (pass) or `false` (fail)

---

## Policy Implementation Mapping

This section maps policy requirements to input data sources.

### Policy Requirements

| Policy Rule | Input Source | Access Path | Description |
|-------------|--------------|-------------|-------------|
| **Attestation Required** | Artifact Metadata | `input.metadata.provenance.attestation_verified` | Verify artifact has valid attestation |
| **No Unapproved Deletions** | Terraform Plan + Metadata | `input.plan.resource_changes[].change.actions` + `input.metadata.deletion_approved` | Block destructive changes without approval |
| **Valid Provenance** | Artifact Metadata | `input.metadata.provenance.render_run_id` | Ensure provenance information is complete |
| **PR Approval** | Artifact Metadata | `input.metadata.provenance.pr_number` + `input.metadata.provenance.approver` | Verify PR approval information |
| **Resource Type Validation** | Terraform Plan | `input.plan.resource_changes[].type` | Validate resource types are allowed |
| **VLAN Boundary** | Terraform Plan | `input.plan.resource_changes[].change.after.vlan_id` | Ensure VLANs are within allowed ranges |

### Policy File Mapping

| Policy File | Input Usage | Description |
|-------------|-------------|-------------|
| `.github/policies/terraform_plan.rego` | `input.plan.*`, `input.metadata.*` | Main policy rules for plan evaluation |
| `.github/policies/common.rego` | N/A (helper functions only) | Reusable helper functions |

### Example Policy Rule with Input Mapping

```rego
# File: .github/policies/terraform_plan.rego
package terraform.plan

import future.keywords.contains
import future.keywords.if

# Policy Rule: No unapproved deletions
# Input Mapping:
#   - input.plan.resource_changes[].change.actions (check for "delete")
#   - input.metadata.deletion_approved (check approval flag)
deny contains msg if {
    has_destructive_changes              # Uses input.plan.resource_changes
    not deletion_approved                # Uses input.metadata.deletion_approved
    msg := sprintf("Destructive changes detected without deletion approval - %d resource(s) to be deleted",
                   [count(resources_to_delete)])
}

# Helper: Check for destructive changes
# Input: input.plan.resource_changes
has_destructive_changes if {
    count(resources_to_delete) > 0
}

# Helper: Get resources to delete
# Input: input.plan.resource_changes
resources_to_delete contains resource if {
    some resource in input.plan.resource_changes
    "delete" in resource.change.actions
}

# Helper: Check deletion approval flag
# Input: input.metadata.deletion_approved
deletion_approved if {
    input.metadata.deletion_approved == true
}
```

---

## Contract Versioning

### Current Version

**Version**: 1.0.0

**Status**: Stable

**Release Date**: Phase 5

### Versioning Scheme

**Format**: Semantic Versioning (MAJOR.MINOR.PATCH)

- **MAJOR**: Breaking changes to input format or structure
- **MINOR**: New optional fields or non-breaking additions
- **PATCH**: Documentation updates or clarifications

### Stability Guarantees

**STABLE (v1.0.0)**:
- ✅ Combined input structure (`plan` + `metadata` keys) will NOT change
- ✅ Required fields in metadata will NOT be removed or renamed
- ✅ Terraform plan JSON follows Terraform's own stability guarantees
- ✅ Policy access paths (`input.plan.*`, `input.metadata.*`) will NOT change

**ADDITIONS ALLOWED**:
- ✅ New optional fields in metadata structure
- ✅ New derived scoped change helpers in policies
- ✅ Additional validation rules (with proper notice)

**BREAKING CHANGES REQUIRE MAJOR VERSION**:
- ❌ Renaming metadata fields
- ❌ Changing metadata field types
- ❌ Removing required fields
- ❌ Changing input document structure

### Deprecation Policy

- Breaking changes will be announced at least 30 days in advance
- Deprecated fields will continue to work for at least one MAJOR version
- Migration guides will be provided for breaking changes

---

## Explicit Non-Goals

The following are explicitly OUT OF SCOPE for this phase:

### ❌ Multi-Environment Policy Targeting

**Not Implemented**: Different input formats for dev/staging/prod environments

**Reason**: Single environment scope for this phase. All inputs use the same format regardless of target environment.

**Future**: May be added in later phases if needed via additional metadata fields

### ❌ Drift Reconciliation Inputs

**Not Implemented**: Input formats for comparing current state vs. desired state (drift detection)

**Reason**: Current focus is on plan-time evaluation only. Drift detection would require different input sources (actual state data).

**Future**: Separate input contract may be defined for drift reconciliation workflows

### ❌ Raw Log Parsing

**Not Implemented**: Parsing of Terraform logs, GitHub Actions logs, or any text-based output

**Reason**: Violates structured data principle. All inputs MUST be structured JSON.

**Future**: Will not be implemented (by design)

### ❌ External Data Sources

**Not Implemented**: Policy rules that fetch data from external APIs, databases, or files

**Reason**: Violates deterministic execution principle. All inputs MUST be provided explicitly.

**Future**: Will not be implemented (by design)

---

## Testing and Validation

### Input Validation

All inputs are validated before policy evaluation:

1. **JSON Syntax**: Files must be valid JSON
2. **Schema Compliance**: Metadata must match schema
3. **Required Fields**: All required fields must be present
4. **Type Checking**: Field values must match expected types

### Testing Locally

You can test policy evaluation locally with sample inputs:

```bash
# Create sample input document
cat > test-input.json << 'EOF'
{
  "plan": {
    "format_version": "1.2",
    "resource_changes": [
      {
        "address": "unifi_network.test",
        "type": "unifi_network",
        "change": {
          "actions": ["create"],
          "after": {
            "name": "Test Network",
            "vlan_id": 10
          }
        }
      }
    ]
  },
  "metadata": {
    "artifact": {
      "path": "site-test.tfvars.json",
      "site": "test"
    },
    "provenance": {
      "render_run_id": "123456789",
      "attestation_verified": true,
      "pr_number": "1",
      "approver": "testuser",
      "approved_at": "2024-01-15T10:30:00Z"
    },
    "deletion_approved": false
  }
}
EOF

# Install OPA
curl -L -o opa https://github.com/open-policy-agent/opa/releases/download/v0.60.0/opa_linux_amd64_static
chmod +x opa

# Evaluate policy
./opa eval --bundle .github/policies/ --input test-input.json 'data.terraform.plan.allow'

# Get detailed results
./opa eval --bundle .github/policies/ --input test-input.json 'data.terraform.plan.summary'
./opa eval --bundle .github/policies/ --input test-input.json 'data.terraform.plan.deny'
./opa eval --bundle .github/policies/ --input test-input.json 'data.terraform.plan.violations'
```

### Compliance Checklist

Use this checklist to verify inputs comply with the contract:

#### Terraform Plan JSON
- [ ] Generated by `terraform show -json` (not manually created)
- [ ] Contains `format_version` field
- [ ] Contains `terraform_version` field
- [ ] Contains `resource_changes` array (may be empty)
- [ ] Valid JSON syntax
- [ ] Follows Terraform JSON plan format specification

#### Artifact Metadata
- [ ] Valid JSON syntax
- [ ] Contains all required fields (`artifact.path`, `artifact.site`, `provenance.*`)
- [ ] `attestation_verified` is boolean
- [ ] `deletion_approved` is boolean
- [ ] `render_run_id` is non-empty string
- [ ] `pr_number` is non-empty string
- [ ] `approver` is non-empty string
- [ ] `approved_at` is ISO 8601 timestamp

#### Combined Input Document
- [ ] Valid JSON syntax
- [ ] Contains `plan` key with Terraform plan JSON
- [ ] Contains `metadata` key with artifact metadata
- [ ] No additional top-level keys
- [ ] File size is reasonable (< 100MB)

---

## Troubleshooting

### Policy Input Issues

#### Invalid JSON Syntax

**Error**: `invalid character...` or `unexpected end of JSON`

**Cause**: Malformed JSON in input document

**Solution**:
1. Validate JSON syntax: `jq . policy-input.json`
2. Check for missing commas, brackets, or quotes
3. Verify all strings are properly escaped

#### Missing Required Field

**Error**: Policy fails with undefined field access

**Cause**: Required metadata field is missing

**Solution**:
1. Verify metadata includes all required fields
2. Check workflow step that generates metadata
3. Ensure field names match exactly (case-sensitive)

#### Attestation Not Verified

**Error**: Policy denies with "Artifact attestation verification failed"

**Cause**: `attestation_verified` is `false` or missing

**Solution**:
1. Check attestation verification step output
2. Verify artifact has valid SLSA provenance
3. Re-run render workflow to generate attested artifact

#### Unexpected Policy Results

**Error**: Policy evaluation returns unexpected pass/fail

**Cause**: Input data doesn't match expectations

**Solution**:
1. Review input document: `cat policy-input.json | jq .`
2. Test policy locally with input
3. Check policy logic in `.github/policies/terraform_plan.rego`
4. Verify scoped change rules are correct

---

## References

### Related Documentation

- **Policy Engine**: [docs/phase5/policy-engine.md](../phase5/policy-engine.md) - OPA integration and evaluation
- **Terraform Input Contract**: [docs/phase4/terraform-input-contract.md](../phase4/terraform-input-contract.md) - Artifact format specification
- **Attestation Gate**: [docs/phase4/attestation-gate.md](../phase4/attestation-gate.md) - Artifact verification
- **Security Boundaries**: [docs/phase4/security.md](../phase4/security.md) - Trust model and boundaries

### Implementation Files

- **Policy Files**: `.github/policies/terraform_plan.rego`, `.github/policies/common.rego`
- **Workflow**: `.github/workflows/terraform-plan.yaml` - Policy evaluation implementation
- **Policy Documentation**: `.github/policies/README.md` - Policy usage guide

### External Standards

- **Terraform JSON Format**: https://developer.hashicorp.com/terraform/internals/json-format
- **OPA/Rego Documentation**: https://www.openpolicyagent.org/docs/latest/
- **JSON Schema**: https://json-schema.org/draft-07/schema
- **SLSA Provenance**: https://slsa.dev/provenance/v1
- **ISO 8601 Timestamps**: https://en.wikipedia.org/wiki/ISO_8601

---

## Version History

| Version | Date | Changes |
|---------|------|---------|
| 1.0.0 | Phase 5 | Initial policy input contract definition |

---

**Document Status**: Stable

**Contract Owner**: Infrastructure Team

**Review Schedule**: Every phase or when input formats change
