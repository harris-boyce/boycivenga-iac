# Attestation Implementation Documentation

## Overview

This document describes the implementation of artifact attestation in the render pipeline (Phase 3). Attestations provide cryptographic proof of artifact provenance, ensuring that artifacts have not been tampered with and originate from trusted sources using GitHub OIDC identity and SLSA provenance.

## Purpose

Artifact attestation serves several critical security and compliance purposes:

- **Verify Artifact Integrity**: Ensure artifacts have not been modified after generation
- **Establish Provenance**: Prove artifacts were generated by trusted CI/CD workflows
- **Enable Auditability**: Maintain cryptographic records of artifact generation
- **Support Compliance**: Meet security requirements for infrastructure supply chain management
- **Supply Chain Security**: Protect against tampering in the artifact delivery pipeline

## Implementation Details

### Workflow Integration

Attestations are generated in the `.github/workflows/render-artifacts.yaml` workflow immediately after each artifact is uploaded. This ensures that every artifact produced by the pipeline has corresponding provenance attestations.

**Workflow:** `.github/workflows/render-artifacts.yaml`

### Required Permissions

The workflow requires the following GitHub Actions permissions:

```yaml
permissions:
  contents: write
  pull-requests: write
  id-token: write      # Required for GitHub OIDC attestation
  attestations: write  # Required for creating attestations
```

- **`id-token: write`**: Allows the workflow to obtain an OIDC token from GitHub for keyless signing
- **`attestations: write`**: Permits the workflow to create and attach attestations to the repository

### Attestation Action

We use the official GitHub Actions attestation action:

```yaml
- uses: actions/attest-build-provenance@v1
  with:
    subject-path: 'artifacts/path/*.json'
```

**Action:** `actions/attest-build-provenance@v1`

This action:
1. Generates SLSA provenance metadata for the specified artifacts
2. Signs the provenance using GitHub's OIDC identity (keyless signing via Sigstore)
3. Publishes the attestation to the GitHub Attestations API
4. Makes attestations available for verification

## Attested Artifacts

The following artifacts are attested in the render pipeline:

### 1. Terraform Input Files (tfvars)

**Files**: `artifacts/tfvars/*.json`

**Attestation Step**:
```yaml
- name: Attest Terraform tfvars Artifacts
  uses: actions/attest-build-provenance@v1
  with:
    subject-path: 'artifacts/tfvars/*.json'
```

**Description**: Site-specific Terraform variable files generated from NetBox intent data. These JSON files contain infrastructure configuration parameters consumed by Terraform modules.

**Examples**:
- `site-pennington.tfvars.json`
- `site-countfleetcourt.tfvars.json`

**Rationale**: These files directly influence infrastructure deployment and must be verifiable to prevent unauthorized modifications between generation and application.

### 2. UniFi Configuration Payloads

**Files**: `artifacts/unifi/*.json`

**Attestation Step**:
```yaml
- name: Attest UniFi Configuration Artifacts
  uses: actions/attest-build-provenance@v1
  with:
    subject-path: 'artifacts/unifi/*.json'
```

**Description**: UniFi controller configuration files generated from NetBox intent data. These JSON payloads define network configurations including sites, networks, VLANs, and WLANs.

**Examples**:
- `site-pennington.json`
- `site-countfleetcourt.json`

**Rationale**: These files represent intended network state and must be attested to ensure that network configurations applied to UniFi controllers are traceable to the automated pipeline.

### 3. NetBox Intent Export Snapshots

**Files**: `artifacts/intent-export/*.json` and `artifacts/intent-export/*.yaml`

**Attestation Steps**:
```yaml
- name: Attest NetBox Export Artifacts
  uses: actions/attest-build-provenance@v1
  with:
    subject-path: 'artifacts/intent-export/*.json'

- name: Attest NetBox Export YAML Artifacts
  uses: actions/attest-build-provenance@v1
  with:
    subject-path: 'artifacts/intent-export/*.yaml'
```

**Description**: Raw NetBox API export data including sites, prefixes, VLANs, and tags. This represents the source of truth for network intent at the time of artifact generation.

**Examples**:
- `sites.json` / `sites.yaml`
- `prefixes.json` / `prefixes.yaml`
- `vlans.json` / `vlans.yaml`
- `tags.json` / `tags.yaml`

**Rationale**: These exports serve as the authoritative source data for all downstream artifacts. Attesting these files provides an audit trail back to the original NetBox state and enables verification that rendered artifacts derive from the correct source data.

## SLSA Provenance

### What is SLSA?

[SLSA (Supply-chain Levels for Software Artifacts)](https://slsa.dev/) is a security framework for ensuring the integrity of software artifacts throughout the software supply chain. SLSA provenance provides a standardized way to document how an artifact was built.

### Provenance Contents

Each attestation includes the following SLSA provenance information:

- **Subject**: The artifact being attested (file name and digest)
- **Predicate Type**: `https://slsa.dev/provenance/v1`
- **Builder Identity**: GitHub Actions workflow
- **Build Invocation**:
  - Workflow name: `Render Artifacts`
  - Workflow path: `.github/workflows/render-artifacts.yaml`
  - Repository: `harris-boyce/boycivenga-iac`
  - Commit SHA: The exact commit that triggered the workflow
  - Workflow trigger: `push`, `schedule`, or `workflow_dispatch`
- **Build Metadata**:
  - Build start time
  - Build finish time
  - Workflow run ID
  - Workflow run number
- **Materials**: Source repository and commit information

### SLSA Level

The current implementation achieves **SLSA Build Level 2**:

- ✅ **Build service**: Hosted on GitHub Actions
- ✅ **Build as code**: Workflow defined in version control
- ✅ **Provenance generation**: Automatic attestation creation
- ✅ **Signed provenance**: Keyless signing via Sigstore/GitHub OIDC
- ✅ **Service-generated provenance**: GitHub generates provenance metadata

**Future Enhancement**: The long-term goal is to achieve SLSA Build Level 3, which would require:
- Additional build platform hardening
- Non-falsifiable provenance (provenance generation integrated into the build service)
- Stronger isolation guarantees

See [attestation-scope.md](attestation-scope.md) for details on the SLSA roadmap.

## GitHub OIDC Identity

### How It Works

GitHub Actions provides OpenID Connect (OIDC) tokens that can be used for keyless signing without requiring long-lived credentials or secrets.

**Key Benefits**:
- ✅ No secrets to manage
- ✅ No key rotation required
- ✅ Automatic identity verification
- ✅ Audit trail through GitHub

**Process**:
1. Workflow requests an OIDC token from GitHub
2. GitHub issues a short-lived token with workflow identity claims
3. Token is used to sign attestations via Sigstore
4. Public transparency log records the signing event
5. Attestations can be verified using the public record

**Identity Claims in Token**:
- Repository owner and name
- Workflow name and path
- Commit SHA
- Git ref (branch/tag)
- Workflow trigger event

### Sigstore Integration

Attestations are signed using [Sigstore](https://www.sigstore.dev/), an industry-standard keyless signing infrastructure.

**Components**:
- **Fulcio**: Certificate authority for code signing
- **Rekor**: Transparency log for signature verification
- **Cosign**: Tool for container and artifact signing

The `actions/attest-build-provenance` action automatically handles the Sigstore integration, so no additional configuration is required.

## Deterministic and Reproducible Output

All attestations are **deterministic** and **reproducible**:

### Determinism

Given the same inputs, the attestation will always produce the same artifact digests:
- Artifact contents are hashed using SHA-256
- SLSA provenance includes immutable metadata (commit SHA, workflow path)
- Timestamps reflect actual build time (expected to vary)

### Reproducibility

The attestation process is reproducible:
- Same workflow run will produce consistent attestations
- Same artifacts will have consistent digests
- Provenance metadata accurately reflects build environment
- All steps are idempotent and automated

**Note**: While the artifact digests and provenance structure are deterministic, the signature and timestamp will vary for each workflow run. This is expected and does not affect verification.

## Verifying Attestations

### Using GitHub CLI

Attestations can be verified using the GitHub CLI:

```bash
# Verify an attestation for a specific artifact
gh attestation verify <artifact-path> \
  --owner harris-boyce \
  --repo boycivenga-iac

# Example: Verify a Terraform tfvars file
gh attestation verify site-pennington.tfvars.json \
  --owner harris-boyce \
  --repo boycivenga-iac
```

**Prerequisites**:
- GitHub CLI (`gh`) version 2.49.0 or later
- Artifact file downloaded locally

**Verification Output**:
```
✓ Verification succeeded!

Attestation details:
  Repository: harris-boyce/boycivenga-iac
  Workflow: .github/workflows/render-artifacts.yaml
  Commit SHA: abc123...
  Issued at: 2025-12-18T05:30:00Z
```

### Using Cosign

For more advanced verification or integration with other tools, use `cosign`:

```bash
# Install cosign
brew install cosign  # macOS
# or download from https://github.com/sigstore/cosign/releases

# Verify attestation
cosign verify-attestation \
  --type slsaprovenance \
  --certificate-identity-regexp "^https://github.com/harris-boyce/boycivenga-iac" \
  --certificate-oidc-issuer https://token.actions.githubusercontent.com \
  <artifact-oci-reference>
```

### Programmatic Verification

Attestations can also be verified programmatically:

**Python Example**:
```python
import subprocess
import json

def verify_attestation(artifact_path, owner, repo):
    """Verify GitHub attestation for an artifact."""
    cmd = [
        "gh", "attestation", "verify", artifact_path,
        "--owner", owner,
        "--repo", repo,
        "--format", "json"
    ]
    
    result = subprocess.run(cmd, capture_output=True, text=True)
    
    if result.returncode == 0:
        attestation_data = json.loads(result.stdout)
        return True, attestation_data
    else:
        return False, result.stderr

# Usage
success, data = verify_attestation(
    "site-pennington.tfvars.json",
    "harris-boyce",
    "boycivenga-iac"
)

if success:
    print("✓ Attestation verified successfully")
    print(f"  Workflow: {data['workflow']}")
    print(f"  Commit: {data['commit']}")
else:
    print(f"✗ Verification failed: {data}")
```

### CI/CD Integration

Attestation verification can be integrated into deployment workflows:

```yaml
# Example: Verify attestation before applying Terraform
- name: Download artifact
  run: gh run download ${{ inputs.run-id }} --name terraform-tfvars

- name: Verify attestation
  run: |
    for file in artifacts/tfvars/*.json; do
      gh attestation verify "$file" \
        --owner harris-boyce \
        --repo boycivenga-iac
    done

- name: Apply Terraform
  if: success()
  run: terraform apply -var-file=artifacts/tfvars/site-pennington.tfvars.json
```

## Attestation Storage

### GitHub Attestations API

Attestations are stored using the GitHub Attestations API:

- **Retention**: Attestations are retained indefinitely as part of the repository
- **Access**: Attestations are publicly accessible for public repositories
- **API Endpoint**: `https://api.github.com/repos/{owner}/{repo}/attestations`

### Transparency Log

All attestations are also recorded in the Sigstore Rekor transparency log:

- **Public Record**: All signatures are logged publicly
- **Immutable**: Log entries cannot be modified or deleted
- **Auditable**: Anyone can verify signatures against the log
- **Search**: Attestations can be searched by artifact digest or repository

**View in Rekor**:
```bash
# Search for attestations by artifact digest
rekor-cli search --sha <artifact-sha256>

# Get log entry details
rekor-cli get --log-index <log-index>
```

## Security Considerations

### Trust Model

The attestation security model relies on:

1. **GitHub Identity**: Trust in GitHub's OIDC token issuance
2. **Workflow Integrity**: Trust that the workflow file has not been tampered with
3. **Sigstore**: Trust in the Sigstore transparency log and certificate authority
4. **Artifact Integrity**: SHA-256 digests ensure artifacts have not been modified

### Attack Scenarios and Mitigations

**Scenario 1: Attacker modifies artifact after generation**
- **Mitigation**: Attestation digest will not match the modified artifact
- **Detection**: Verification will fail

**Scenario 2: Attacker attempts to forge attestation**
- **Mitigation**: Attestations are signed with OIDC token unique to the workflow
- **Detection**: Signature will not verify against the repository identity

**Scenario 3: Attacker modifies workflow to generate malicious artifacts**
- **Mitigation**: Workflow changes require code review and are version controlled
- **Detection**: Provenance includes commit SHA, allowing audit of workflow changes
- **Additional Protection**: Use branch protection rules and required reviews

**Scenario 4: Attacker replays old attestation with old artifact**
- **Mitigation**: Provenance includes timestamp and commit SHA
- **Detection**: Stale artifacts can be identified by timestamp
- **Additional Protection**: Implement freshness checks in deployment workflows

### Best Practices

When using attested artifacts:

1. **Always verify attestations** before using artifacts in production
2. **Check commit SHA** in provenance to ensure artifacts are from expected source
3. **Validate freshness** by checking build timestamp
4. **Use branch protection** to prevent unauthorized workflow modifications
5. **Review workflow changes** carefully, especially in attestation steps
6. **Monitor Rekor logs** for unexpected signing events
7. **Implement policy enforcement** in deployment workflows
8. **Document verification procedures** for all consumers

### Limitations

Current limitations and known issues:

- **YAML wildcards**: The `attest-build-provenance` action may have issues with certain glob patterns. We use separate steps for JSON and YAML to ensure all files are attested.
- **Large artifacts**: Very large artifact sets may encounter API rate limits
- **Private repositories**: Attestation visibility follows repository visibility settings
- **Retention**: While attestations are retained indefinitely, artifacts have 30-day retention by default

## Troubleshooting

### Attestation Generation Fails

**Symptoms**: Attestation step fails during workflow execution.

**Common Causes**:
1. Missing permissions (`id-token: write` or `attestations: write`)
2. No artifacts found at specified path
3. Network issues connecting to Sigstore services
4. Rate limiting on GitHub API

**Solutions**:
```yaml
# Verify permissions are set
permissions:
  id-token: write
  attestations: write

# Verify artifacts exist before attesting
- name: List artifacts
  run: ls -lah artifacts/tfvars/

- name: Attest artifacts
  if: success()
  uses: actions/attest-build-provenance@v1
  with:
    subject-path: 'artifacts/tfvars/*.json'
```

### Verification Fails

**Symptoms**: `gh attestation verify` returns an error.

**Common Causes**:
1. Artifact has been modified since attestation
2. Artifact was not actually attested
3. Network issues accessing GitHub or Rekor
4. Incorrect repository owner/name specified

**Solutions**:
```bash
# Verify artifact exists
ls -l site-pennington.tfvars.json

# Check artifact digest
sha256sum site-pennington.tfvars.json

# Verify with verbose output
gh attestation verify site-pennington.tfvars.json \
  --owner harris-boyce \
  --repo boycivenga-iac \
  --format json

# Check if attestations exist for the repository
gh api /repos/harris-boyce/boycivenga-iac/attestations
```

### No Attestations Found

**Symptoms**: Verification reports no attestations available for the artifact.

**Common Causes**:
1. Attestation step was skipped in the workflow
2. Workflow permissions were insufficient
3. Artifact name/digest mismatch

**Solutions**:
1. Check workflow run logs for attestation steps
2. Verify permissions are correct in workflow YAML
3. Ensure artifact has not been modified since download
4. Check that the correct artifact was downloaded:
   ```bash
   # List available artifacts
   gh run list --workflow render-artifacts.yaml --limit 1
   gh run view <run-id> --log
   ```

### Permission Denied Errors

**Symptoms**: Workflow fails with permission errors during attestation.

**Solutions**:
```yaml
# Ensure repository settings allow attestations
# Settings → Actions → General → Workflow permissions
# Set to "Read and write permissions"

# Verify permissions in workflow
permissions:
  id-token: write      # Must be write
  attestations: write  # Must be write
```

## Maintenance and Updates

### Updating the Attestation Action

The `actions/attest-build-provenance` action is periodically updated by GitHub. To update:

```yaml
# Current version
- uses: actions/attest-build-provenance@v1

# To update to a specific version
- uses: actions/attest-build-provenance@v1.2.3

# To use the latest v1 (recommended)
- uses: actions/attest-build-provenance@v1
```

**Update Process**:
1. Check [action releases](https://github.com/actions/attest-build-provenance/releases)
2. Review changelog for breaking changes
3. Update workflow file
4. Test with a manual workflow run
5. Monitor attestation generation and verification

### Monitoring Attestations

Recommended monitoring practices:

1. **Workflow Success Rate**: Monitor attestation step success rate
2. **Verification Failures**: Track verification failures in deployment workflows
3. **Rekor Log**: Periodically audit Rekor entries for the repository
4. **API Usage**: Monitor GitHub API rate limits for attestations

**Example Monitoring Query**:
```bash
# Count attestations for recent runs
gh api /repos/harris-boyce/boycivenga-iac/attestations \
  --jq '.attestations | length'

# Check recent workflow runs for attestation failures
gh run list --workflow render-artifacts.yaml --limit 10 \
  --json conclusion,name,workflowName
```

## Related Documentation

- [attestation-scope.md](attestation-scope.md) - Attestation design and scope definition
- [../render-pipeline.md](../render-pipeline.md) - Complete render pipeline documentation
- [SLSA Framework](https://slsa.dev/) - Supply-chain security framework
- [Sigstore Documentation](https://docs.sigstore.dev/) - Sigstore project documentation
- [GitHub Attestations](https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds) - GitHub attestation documentation

## Changelog

### Phase 3 Initial Implementation (2025-12-18)

- Implemented SLSA provenance attestation for all artifacts
- Added GitHub OIDC identity integration
- Configured attestation for:
  - Terraform tfvars (JSON)
  - UniFi configurations (JSON)
  - NetBox exports (JSON and YAML)
- Added workflow permissions for `id-token: write` and `attestations: write`
- Created comprehensive attestation documentation
- Achieved SLSA Build Level 2 compliance

## Support

For questions or issues with attestations:

1. Review this documentation and troubleshooting section
2. Check workflow run logs in GitHub Actions
3. Verify attestations exist using `gh attestation verify`
4. Review [CONTRIBUTING.md](../../CONTRIBUTING.md) for development guidelines
5. Open an issue with:
   - Workflow run ID
   - Attestation step logs
   - Verification error messages
   - Artifact details (name, size, expected digest)
