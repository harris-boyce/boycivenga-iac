# Attestation Implementation Documentation

## Overview

This document describes the implementation of artifact attestation for the render pipeline (Phase 3). Attestations provide cryptographic proof of artifact provenance, ensuring that artifacts have not been tampered with and originate from trusted sources using GitHub OIDC identity and SLSA provenance.

**Note**: While attestation is implemented as part of Phase 3, it extends the Phase 2 render workflow (`.github/workflows/render-artifacts.yaml`) with new attestation capabilities.

## Purpose

Artifact attestation serves several critical security and compliance purposes:

- **Verify Artifact Integrity**: Ensure artifacts have not been modified after generation
- **Establish Provenance**: Prove artifacts were generated by trusted CI/CD workflows
- **Enable Auditability**: Maintain cryptographic records of artifact generation
- **Support Compliance**: Meet security requirements for infrastructure supply chain management
- **Supply Chain Security**: Protect against tampering in the artifact delivery pipeline

## Implementation Details

### Workflow Integration

Attestations are generated in the `.github/workflows/render-artifacts.yaml` workflow immediately after each artifact is uploaded. This ensures that every artifact produced by the pipeline has corresponding provenance attestations.

**Workflow:** `.github/workflows/render-artifacts.yaml`

### Required Permissions

The workflow requires the following GitHub Actions permissions:

```yaml
permissions:
  contents: write
  pull-requests: write
  id-token: write      # Required for GitHub OIDC attestation
  attestations: write  # Required for creating attestations
```

- **`id-token: write`**: Allows the workflow to obtain an OIDC token from GitHub for keyless signing
- **`attestations: write`**: Permits the workflow to create and attach attestations to the repository

### Attestation Action

We use the official GitHub Actions attestation action:

```yaml
- uses: actions/attest-build-provenance@v1
  with:
    subject-path: 'artifacts/path/*.json'
```

**Action:** `actions/attest-build-provenance@v1`

This action:
1. Generates SLSA provenance metadata for the specified artifacts
2. Signs the provenance using GitHub's OIDC identity (keyless signing via Sigstore)
3. Publishes the attestation to the GitHub Attestations API
4. Makes attestations available for verification

## Attested Artifacts

The following artifacts are attested in the render pipeline:

### 1. Terraform Input Files (tfvars)

**Files**: `artifacts/tfvars/*.json`

**Attestation Step**:
```yaml
- name: Attest Terraform tfvars Artifacts
  uses: actions/attest-build-provenance@v1
  with:
    subject-path: 'artifacts/tfvars/*.json'
```

**Description**: Site-specific Terraform variable files generated from NetBox intent data. These JSON files contain infrastructure configuration parameters consumed by Terraform modules.

**Examples**:
- `site-pennington.tfvars.json`
- `site-countfleetcourt.tfvars.json`

**Rationale**: These files directly influence infrastructure deployment and must be verifiable to prevent unauthorized modifications between generation and application.

### 2. UniFi Configuration Payloads

**Files**: `artifacts/unifi/*.json`

**Attestation Step**:
```yaml
- name: Attest UniFi Configuration Artifacts
  uses: actions/attest-build-provenance@v1
  with:
    subject-path: 'artifacts/unifi/*.json'
```

**Description**: UniFi controller configuration files generated from NetBox intent data. These JSON payloads define network configurations including sites, networks, VLANs, and WLANs.

**Examples**:
- `site-pennington.json`
- `site-countfleetcourt.json`

**Rationale**: These files represent intended network state and must be attested to ensure that network configurations applied to UniFi controllers are traceable to the automated pipeline.

### 3. NetBox Intent Export Snapshots

**Files**: `artifacts/intent-export/*.json` and `artifacts/intent-export/*.yaml`

**Attestation Steps**:
```yaml
- name: Attest NetBox Export Artifacts
  uses: actions/attest-build-provenance@v1
  with:
    subject-path: 'artifacts/intent-export/*.json'

- name: Attest NetBox Export YAML Artifacts
  uses: actions/attest-build-provenance@v1
  with:
    subject-path: 'artifacts/intent-export/*.yaml'
```

**Description**: Raw NetBox API export data including sites, prefixes, VLANs, and tags. This represents the source of truth for network intent at the time of artifact generation.

**Examples**:
- `sites.json` / `sites.yaml`
- `prefixes.json` / `prefixes.yaml`
- `vlans.json` / `vlans.yaml`
- `tags.json` / `tags.yaml`

**Rationale**: These exports serve as the authoritative source data for all downstream artifacts. Attesting these files provides an audit trail back to the original NetBox state and enables verification that rendered artifacts derive from the correct source data.

## SLSA Provenance

### What is SLSA?

[SLSA (Supply-chain Levels for Software Artifacts)](https://slsa.dev/) is a security framework for ensuring the integrity of software artifacts throughout the software supply chain. SLSA provenance provides a standardized way to document how an artifact was built.

### Provenance Contents

Each attestation includes the following SLSA provenance information:

- **Subject**: The artifact being attested (file name and digest)
- **Predicate Type**: `https://slsa.dev/provenance/v1`
- **Builder Identity**: GitHub Actions workflow
- **Build Invocation**:
  - Workflow name: `Render Artifacts`
  - Workflow path: `.github/workflows/render-artifacts.yaml`
  - Repository: `harris-boyce/boycivenga-iac`
  - Commit SHA: The exact commit that triggered the workflow
  - Workflow trigger: `push`, `schedule`, or `workflow_dispatch`
- **Build Metadata**:
  - Build start time
  - Build finish time
  - Workflow run ID
  - Workflow run number
- **Materials**: Source repository and commit information

### SLSA Level

The current implementation achieves **SLSA Build Level 2**:

- ✅ **Build service**: Hosted on GitHub Actions
- ✅ **Build as code**: Workflow defined in version control
- ✅ **Provenance generation**: Automatic attestation creation
- ✅ **Signed provenance**: Keyless signing via Sigstore/GitHub OIDC
- ✅ **Service-generated provenance**: GitHub generates provenance metadata

**Future Enhancement**: The long-term goal is to achieve SLSA Build Level 3, which would require:
- Additional build platform hardening
- Non-falsifiable provenance (provenance generation integrated into the build service)
- Stronger isolation guarantees

See [attestation-scope.md](attestation-scope.md) for details on the SLSA roadmap.

## GitHub OIDC Identity

### How It Works

GitHub Actions provides OpenID Connect (OIDC) tokens that can be used for keyless signing without requiring long-lived credentials or secrets.

**Key Benefits**:
- ✅ No secrets to manage
- ✅ No key rotation required
- ✅ Automatic identity verification
- ✅ Audit trail through GitHub

**Process**:
1. Workflow requests an OIDC token from GitHub
2. GitHub issues a short-lived token with workflow identity claims
3. Token is used to sign attestations via Sigstore
4. Public transparency log records the signing event
5. Attestations can be verified using the public record

**Identity Claims in Token**:
- Repository owner and name
- Workflow name and path
- Commit SHA
- Git ref (branch/tag)
- Workflow trigger event

### Sigstore Integration

Attestations are signed using [Sigstore](https://www.sigstore.dev/), an industry-standard keyless signing infrastructure.

**Components**:
- **Fulcio**: Certificate authority for code signing
- **Rekor**: Transparency log for signature verification
- **Cosign**: Tool for container and artifact signing

The `actions/attest-build-provenance` action automatically handles the Sigstore integration, so no additional configuration is required.

## Deterministic and Reproducible Output

All attestations are **deterministic** and **reproducible**:

### Determinism

Given the same inputs, the attestation will always produce the same artifact digests:
- Artifact contents are hashed using SHA-256
- SLSA provenance includes immutable metadata (commit SHA, workflow path)
- Timestamps reflect actual build time (expected to vary)

### Reproducibility

The attestation process is reproducible:
- Same workflow run will produce consistent attestations
- Same artifacts will have consistent digests
- Provenance metadata accurately reflects build environment
- All steps are idempotent and automated

**Note**: While the artifact digests and provenance structure are deterministic, the signature and timestamp will vary for each workflow run. This is expected and does not affect verification.

## Verifying Attestations

Attestation verification ensures that artifacts have not been tampered with and originate from trusted sources. This section describes both local development and CI verification approaches.

**Important:** In Phase 3, verification is **observation only** (non-blocking). Verification failures are logged but do not prevent artifact usage. This allows monitoring of attestation integrity while minimizing operational disruption.

### When to Use Verification

**Recommended Use Cases**:
- **Before deploying artifacts to production**: Verify attestations before applying Terraform configurations or UniFi settings
- **Audit and compliance reviews**: Periodic verification of artifact provenance
- **Security incident response**: Verify artifact integrity after a security event
- **Development and testing**: Validate the attestation workflow is functioning correctly

**Not Required For**:
- Regular development workflows (verification is automated in CI)
- Reviewing artifacts in pull requests (attestations are generated but verification is optional)
- Local testing with artifacts generated locally (no attestations for local builds)

### Local Development Verification

#### Prerequisites

To verify attestations locally, you need:

1. **GitHub CLI** (`gh`) version 2.49.0 or later
   ```bash
   # Check version
   gh --version
   
   # Install/update (macOS)
   brew install gh
   brew upgrade gh
   
   # Install/update (Linux)
   # See https://github.com/cli/cli/blob/trunk/docs/install_linux.md
   ```

2. **Authenticated GitHub CLI**
   ```bash
   # Login to GitHub
   gh auth login
   
   # Verify authentication
   gh auth status
   ```

3. **Downloaded artifacts** from a workflow run

#### Step 1: Download Artifacts

First, download artifacts from a workflow run:

```bash
# List recent render-artifacts workflow runs
gh run list --workflow render-artifacts.yaml --limit 5

# Download artifacts from a specific run
gh run download <run-id>

# Example: Download only terraform-tfvars
gh run download <run-id> --name terraform-tfvars

# Artifacts will be downloaded to the current directory
```

**Example Output**:
```
✓ Created directory terraform-tfvars
✓ Created directory unifi-configurations
✓ Created directory netbox-intent-export
✓ Created directory artifact-summary

Downloaded 4 artifacts (12.5 MB total)
```

#### Step 2: Verify Individual Artifacts

Verify attestations for downloaded artifacts:

```bash
# Verify a Terraform tfvars file
gh attestation verify terraform-tfvars/site-pennington.tfvars.json \
  --owner harris-boyce \
  --repo boycivenga-iac

# Verify a UniFi configuration file
gh attestation verify unifi-configurations/site-countfleetcourt.json \
  --owner harris-boyce \
  --repo boycivenga-iac

# Verify a NetBox export file
gh attestation verify netbox-intent-export/sites.json \
  --owner harris-boyce \
  --repo boycivenga-iac
```

**Example Success Output**:
```
Loaded digest sha256:a3b5c2d1e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1 for file://terraform-tfvars/site-pennington.tfvars.json
Loaded 1 attestation from GitHub API
✓ Verification succeeded!

sha256:a3b5c2d1e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1 was attested by:
REPO                            PREDICATE_TYPE                  WORKFLOW
harris-boyce/boycivenga-iac     https://slsa.dev/provenance/v1  .github/workflows/render-artifacts.yaml@refs/heads/main
```

**Example Failure Output**:
```
Loaded digest sha256:a3b5c2d1e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1 for file://terraform-tfvars/site-pennington.tfvars.json
✗ Verification failed!

Error: no attestations found for artifact
```

#### Step 3: Verify Multiple Artifacts

Verify all artifacts of a specific type:

```bash
# Verify all Terraform tfvars files
for file in terraform-tfvars/*.json; do
  echo "Verifying: $file"
  gh attestation verify "$file" \
    --owner harris-boyce \
    --repo boycivenga-iac
  echo ""
done

# Verify all UniFi configuration files
for file in unifi-configurations/*.json; do
  echo "Verifying: $file"
  gh attestation verify "$file" \
    --owner harris-boyce \
    --repo boycivenga-iac
  echo ""
done

# Verify all NetBox export JSON files
for file in netbox-intent-export/*.json; do
  echo "Verifying: $file"
  gh attestation verify "$file" \
    --owner harris-boyce \
    --repo boycivenga-iac
  echo ""
done

# Verify all NetBox export YAML files
for file in netbox-intent-export/*.yaml; do
  echo "Verifying: $file"
  gh attestation verify "$file" \
    --owner harris-boyce \
    --repo boycivenga-iac
  echo ""
done
```

**Example Batch Output**:
```
Verifying: terraform-tfvars/site-pennington.tfvars.json
✓ Verification succeeded!

Verifying: terraform-tfvars/site-countfleetcourt.tfvars.json
✓ Verification succeeded!

2/2 artifacts verified successfully
```

#### Step 4: View Detailed Attestation Information

Get detailed attestation information in JSON format:

```bash
# Verify with JSON output for programmatic use
gh attestation verify terraform-tfvars/site-pennington.tfvars.json \
  --owner harris-boyce \
  --repo boycivenga-iac \
  --format json | jq '.'

# Extract specific fields
gh attestation verify terraform-tfvars/site-pennington.tfvars.json \
  --owner harris-boyce \
  --repo boycivenga-iac \
  --format json | jq '.verificationResult.statement'
```

**Example JSON Output**:
```json
{
  "verificationResult": {
    "verified": true,
    "statement": {
      "_type": "https://in-toto.io/Statement/v1",
      "subject": [
        {
          "name": "artifacts/tfvars/site-pennington.tfvars.json",
          "digest": {
            "sha256": "a3b5c2d1e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1"
          }
        }
      ],
      "predicateType": "https://slsa.dev/provenance/v1",
      "predicate": {
        "buildDefinition": {
          "buildType": "https://actions.github.io/buildtypes/workflow/v1",
          "externalParameters": {
            "workflow": {
              "ref": "refs/heads/main",
              "repository": "https://github.com/harris-boyce/boycivenga-iac",
              "path": ".github/workflows/render-artifacts.yaml"
            }
          }
        }
      }
    }
  }
}
```

### CI Verification

Attestation verification is automated in the `.github/workflows/verify-attestation.yaml` workflow.

#### Automated Verification Workflow

The verify-attestation workflow provides automated, scheduled verification of all artifacts:

**Features**:
- ✅ **Scheduled execution**: Runs weekly (Mondays at 3 AM UTC)
- ✅ **Manual triggering**: Can be triggered manually with optional run ID
- ✅ **Comprehensive coverage**: Verifies all artifact types (tfvars, UniFi, NetBox exports)
- ✅ **Non-blocking**: Verification failures do not stop the workflow (observation only)
- ✅ **Detailed reporting**: Generates summary with verification counts and status
- ✅ **Audit trail**: All verification results are logged and accessible

**Workflow File**: `.github/workflows/verify-attestation.yaml`

#### Triggering Manual Verification

Run verification manually via GitHub Actions UI:

1. Navigate to **Actions** → **Verify Attestations (Observation Only)**
2. Click **Run workflow**
3. (Optional) Enter a specific workflow run ID to verify
4. Click **Run workflow** button

**Example via GitHub CLI**:
```bash
# Trigger verification for the latest successful run
gh workflow run verify-attestation.yaml

# Trigger verification for a specific run ID
gh workflow run verify-attestation.yaml -f run_id=1234567890
```

#### Verification Workflow Output

The workflow generates a detailed summary showing:

| Artifact Type | Verified | Failed | Total |
|---------------|----------|--------|-------|
| Terraform tfvars | 2 | 0 | 2 |
| UniFi configs | 2 | 0 | 2 |
| NetBox exports (JSON) | 4 | 0 | 4 |
| NetBox exports (YAML) | 4 | 0 | 4 |

**Example Success Log**:
```
=== Verifying Terraform tfvars Attestations ===

Verifying: site-pennington.tfvars.json
✓ Verification succeeded!

Verifying: site-countfleetcourt.tfvars.json
✓ Verification succeeded!

Summary: 2/2 verified, 0 failed
```

**Example Failure Log** (non-blocking):
```
=== Verifying Terraform tfvars Attestations ===

Verifying: site-pennington.tfvars.json
✗ Verification failed!
Error: no attestations found for artifact

Verifying: site-countfleetcourt.tfvars.json
✓ Verification succeeded!

Summary: 1/2 verified, 1 failed
```

#### Integrating Verification into Deployment Workflows

When building deployment workflows that consume artifacts, integrate verification:

```yaml
# Example: Verify before deploying Terraform
name: Deploy Infrastructure

on:
  workflow_dispatch:
    inputs:
      render_run_id:
        description: 'Render artifacts workflow run ID'
        required: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: read
      id-token: read
    steps:
      - name: Download Terraform tfvars
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh run download ${{ inputs.render_run_id }} --name terraform-tfvars

      - name: Verify attestations (non-blocking)
        env:
          GH_TOKEN: ${{ github.token }}
        continue-on-error: true
        run: |
          for file in terraform-tfvars/*.json; do
            echo "Verifying: $file"
            gh attestation verify "$file" \
              --owner ${{ github.repository_owner }} \
              --repo $(basename ${{ github.repository }})
          done

      - name: Apply Terraform
        run: |
          # Apply Terraform configurations
          terraform init
          terraform apply -var-file=terraform-tfvars/site-pennington.tfvars.json -auto-approve
```

**Key Points**:
- Use `continue-on-error: true` for Phase 3 (observation only)
- Log verification results for audit purposes
- Consider making verification blocking in future phases for production deployments

### Programmatic Verification

Attestations can be verified programmatically in scripts:

**Python Example**:
```python
import subprocess
import json
import sys

def verify_attestation(artifact_path, owner, repo):
    """Verify GitHub attestation for an artifact."""
    cmd = [
        "gh", "attestation", "verify", artifact_path,
        "--owner", owner,
        "--repo", repo,
        "--format", "json"
    ]

    result = subprocess.run(cmd, capture_output=True, text=True)

    if result.returncode == 0:
        try:
            attestation_data = json.loads(result.stdout)
            return True, attestation_data
        except json.JSONDecodeError:
            return False, {"error": "Invalid JSON response"}
    else:
        return False, {"error": result.stderr}

# Verify all tfvars files
import glob

artifacts = glob.glob("terraform-tfvars/*.json")
verified_count = 0
failed_count = 0

for artifact in artifacts:
    print(f"Verifying: {artifact}")
    success, data = verify_attestation(
        artifact,
        "harris-boyce",
        "boycivenga-iac"
    )

    if success:
        print("  ✓ Verification succeeded")
        verified_count += 1
    else:
        print(f"  ✗ Verification failed: {data.get('error', 'Unknown error')}")
        failed_count += 1

print(f"\nSummary: {verified_count}/{len(artifacts)} verified, {failed_count} failed")

# Exit with non-zero code if any verification failed (optional for Phase 3)
# sys.exit(1 if failed_count > 0 else 0)
```

**Bash Script Example**:
```bash
#!/bin/bash
# verify-all-artifacts.sh - Verify all downloaded artifacts

set -e

OWNER="harris-boyce"
REPO="boycivenga-iac"

echo "=== Verifying All Artifacts ==="
echo ""

VERIFIED=0
FAILED=0

# Function to verify a file
verify_file() {
    local file="$1"
    echo "Verifying: $(basename "$file")"
    
    if gh attestation verify "$file" --owner "$OWNER" --repo "$REPO" > /dev/null 2>&1; then
        echo "  ✓ Verified"
        VERIFIED=$((VERIFIED + 1))
    else
        echo "  ✗ Failed"
        FAILED=$((FAILED + 1))
    fi
}

# Verify Terraform tfvars
echo "## Terraform tfvars"
for file in terraform-tfvars/*.json 2>/dev/null; do
    [ -f "$file" ] && verify_file "$file"
done
echo ""

# Verify UniFi configs
echo "## UniFi Configurations"
for file in unifi-configurations/*.json 2>/dev/null; do
    [ -f "$file" ] && verify_file "$file"
done
echo ""

# Verify NetBox exports
echo "## NetBox Exports (JSON)"
for file in netbox-intent-export/*.json 2>/dev/null; do
    [ -f "$file" ] && verify_file "$file"
done
echo ""

echo "## NetBox Exports (YAML)"
for file in netbox-intent-export/*.yaml 2>/dev/null; do
    [ -f "$file" ] && verify_file "$file"
done
echo ""

# Summary
TOTAL=$((VERIFIED + FAILED))
echo "=== Summary ==="
echo "Verified: $VERIFIED"
echo "Failed: $FAILED"
echo "Total: $TOTAL"

# Exit with success (Phase 3 observation only)
exit 0
```

### Using Cosign (Advanced)

For more advanced verification or integration with non-GitHub tools, use `cosign`:

```bash
# Install cosign
brew install cosign  # macOS
# or download from https://github.com/sigstore/cosign/releases

# Note: GitHub attestations are stored in the GitHub Attestations API,
# not as OCI artifacts, so cosign verification requires additional setup
# and is not the primary recommended method for this repository.

# For GitHub attestations, use `gh attestation verify` instead (see above)
```

**Note**: While cosign supports SLSA provenance verification, GitHub's attestation workflow stores attestations in the GitHub Attestations API rather than as OCI artifacts. For this repository, `gh attestation verify` is the recommended verification method.

## Attestation Storage

### GitHub Attestations API

Attestations are stored using the GitHub Attestations API:

- **Retention**: Attestations are retained indefinitely as part of the repository
- **Access**: Attestations are publicly accessible for public repositories
- **API Endpoint**: `https://api.github.com/repos/{owner}/{repo}/attestations`

### Transparency Log

All attestations are also recorded in the Sigstore Rekor transparency log:

- **Public Record**: All signatures are logged publicly
- **Immutable**: Log entries cannot be modified or deleted
- **Auditable**: Anyone can verify signatures against the log
- **Search**: Attestations can be searched by artifact digest or repository

**View in Rekor**:
```bash
# Search for attestations by artifact digest
rekor-cli search --sha <artifact-sha256>

# Get log entry details
rekor-cli get --log-index <log-index>
```

## Security Considerations

### Trust Model

The attestation security model relies on:

1. **GitHub Identity**: Trust in GitHub's OIDC token issuance
2. **Workflow Integrity**: Trust that the workflow file has not been tampered with
3. **Sigstore**: Trust in the Sigstore transparency log and certificate authority
4. **Artifact Integrity**: SHA-256 digests ensure artifacts have not been modified

### Attack Scenarios and Mitigations

**Scenario 1: Attacker modifies artifact after generation**
- **Mitigation**: Attestation digest will not match the modified artifact
- **Detection**: Verification will fail

**Scenario 2: Attacker attempts to forge attestation**
- **Mitigation**: Attestations are signed with OIDC token unique to the workflow
- **Detection**: Signature will not verify against the repository identity

**Scenario 3: Attacker modifies workflow to generate malicious artifacts**
- **Mitigation**: Workflow changes require code review and are version controlled
- **Detection**: Provenance includes commit SHA, allowing audit of workflow changes
- **Additional Protection**: Use branch protection rules and required reviews

**Scenario 4: Attacker replays old attestation with old artifact**
- **Mitigation**: Provenance includes timestamp and commit SHA
- **Detection**: Stale artifacts can be identified by timestamp
- **Additional Protection**: Implement freshness checks in deployment workflows

### Best Practices

When using attested artifacts:

1. **Always verify attestations** before using artifacts in production
2. **Check commit SHA** in provenance to ensure artifacts are from expected source
3. **Validate freshness** by checking build timestamp
4. **Use branch protection** to prevent unauthorized workflow modifications
5. **Review workflow changes** carefully, especially in attestation steps
6. **Monitor Rekor logs** for unexpected signing events
7. **Implement policy enforcement** in deployment workflows
8. **Document verification procedures** for all consumers

### Limitations

Current limitations and known issues:

- **Separate steps for file types**: We use separate attestation steps for JSON and YAML files to ensure maximum compatibility. While bash glob patterns support `*.{json,yaml}`, the `attest-build-provenance` action's behavior with brace expansion is not documented, so we use explicit patterns for reliability.
- **Large artifacts**: Very large artifact sets may encounter API rate limits
- **Private repositories**: Attestation visibility follows repository visibility settings
- **Retention**: While attestations are retained indefinitely, artifacts have 30-day retention by default

## Troubleshooting

### Attestation Generation Fails

**Symptoms**: Attestation step fails during workflow execution.

**Common Causes**:
1. Missing permissions (`id-token: write` or `attestations: write`)
2. No artifacts found at specified path
3. Network issues connecting to Sigstore services
4. Rate limiting on GitHub API

**Solutions**:
```yaml
# Verify permissions are set
permissions:
  id-token: write
  attestations: write

# Verify artifacts exist before attesting
- name: List artifacts
  run: ls -lah artifacts/tfvars/

- name: Attest artifacts
  if: success()
  uses: actions/attest-build-provenance@v1
  with:
    subject-path: 'artifacts/tfvars/*.json'
```

### Verification Fails

**Symptoms**: `gh attestation verify` returns an error.

**Common Causes**:
1. Artifact has been modified since attestation
2. Artifact was not actually attested
3. Network issues accessing GitHub or Rekor
4. Incorrect repository owner/name specified

**Solutions**:
```bash
# Verify artifact exists
ls -l site-pennington.tfvars.json

# Check artifact digest
sha256sum site-pennington.tfvars.json

# Verify with verbose output
gh attestation verify site-pennington.tfvars.json \
  --owner harris-boyce \
  --repo boycivenga-iac \
  --format json

# Check if attestations exist for the repository
gh api /repos/harris-boyce/boycivenga-iac/attestations
```

### No Attestations Found

**Symptoms**: Verification reports no attestations available for the artifact.

**Common Causes**:
1. Attestation step was skipped in the workflow
2. Workflow permissions were insufficient
3. Artifact name/digest mismatch

**Solutions**:
1. Check workflow run logs for attestation steps
2. Verify permissions are correct in workflow YAML
3. Ensure artifact has not been modified since download
4. Check that the correct artifact was downloaded:
   ```bash
   # List available artifacts
   gh run list --workflow render-artifacts.yaml --limit 1
   gh run view <run-id> --log
   ```

### Permission Denied Errors

**Symptoms**: Workflow fails with permission errors during attestation.

**Solutions**:
```yaml
# Ensure repository settings allow attestations
# Settings → Actions → General → Workflow permissions
# Set to "Read and write permissions"

# Verify permissions in workflow
permissions:
  id-token: write      # Must be write
  attestations: write  # Must be write
```

## Maintenance and Updates

### Updating the Attestation Action

The `actions/attest-build-provenance` action is periodically updated by GitHub. To update:

```yaml
# Current version
- uses: actions/attest-build-provenance@v1

# To update to a specific version
- uses: actions/attest-build-provenance@v1.2.3

# To use the latest v1 (recommended)
- uses: actions/attest-build-provenance@v1
```

**Update Process**:
1. Check [action releases](https://github.com/actions/attest-build-provenance/releases)
2. Review changelog for breaking changes
3. Update workflow file
4. Test with a manual workflow run
5. Monitor attestation generation and verification

### Monitoring Attestations

Recommended monitoring practices:

1. **Workflow Success Rate**: Monitor attestation step success rate
2. **Verification Failures**: Track verification failures in deployment workflows
3. **Rekor Log**: Periodically audit Rekor entries for the repository
4. **API Usage**: Monitor GitHub API rate limits for attestations

**Example Monitoring Query**:
```bash
# Count attestations for recent runs
gh api /repos/harris-boyce/boycivenga-iac/attestations \
  --jq '.attestations | length'

# Check recent workflow runs for attestation failures
gh run list --workflow render-artifacts.yaml --limit 10 \
  --json conclusion,name,workflowName
```

## Related Documentation

- [attestation-scope.md](./attestation-scope.md) - Attestation design and scope definition
- [../render-pipeline.md](../render-pipeline.md) - Complete render pipeline documentation
- [SLSA Framework](https://slsa.dev/) - Supply-chain security framework
- [Sigstore Documentation](https://docs.sigstore.dev/) - Sigstore project documentation
- [GitHub Attestations](https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds) - GitHub attestation documentation

## Changelog

### Phase 3 Initial Implementation (2025-12-18)

- Implemented SLSA provenance attestation for all artifacts
- Added GitHub OIDC identity integration
- Configured attestation for:
  - Terraform tfvars (JSON)
  - UniFi configurations (JSON)
  - NetBox exports (JSON and YAML)
- Added workflow permissions for `id-token: write` and `attestations: write`
- Created comprehensive attestation documentation
- Achieved SLSA Build Level 2 compliance

## Support

For questions or issues with attestations:

1. Review this documentation and troubleshooting section
2. Check workflow run logs in GitHub Actions
3. Verify attestations exist using `gh attestation verify`
4. Review [CONTRIBUTING.md](../../CONTRIBUTING.md) for development guidelines
5. Open an issue with:
   - Workflow run ID
   - Attestation step logs
   - Verification error messages
   - Artifact details (name, size, expected digest)
